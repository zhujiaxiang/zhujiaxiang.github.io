<!DOCTYPE html>
<html lang="z">
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>LeetCodePageOne | Lio&#39;s dream</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="461. Hamming DistanceThe Hamming distance between two integers is the number of positions at which the corresponding bits are different.
Given two integers x and y, calculate the Hamming distance.
Not">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="LeetCodePageOne | Lio&#39;s dream">
    <meta name="twitter:description" content="461. Hamming DistanceThe Hamming distance between two integers is the number of positions at which the corresponding bits are different.
Given two integers x and y, calculate the Hamming distance.
Not">

    <meta property="og:type" content="article">
    <meta property="og:title" content="LeetCodePageOne | Lio&#39;s dream">
    <meta property="og:description" content="461. Hamming DistanceThe Hamming distance between two integers is the number of positions at which the corresponding bits are different.
Given two integers x and y, calculate the Hamming distance.
Not">

    
    <meta name="author" content="Lio">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/images/avatar-small.png">
    

    <meta name="generator" content="hexo"/>
    
    <link rel="alternate" type="application/rss+xml" title="Lio&#39;s dream" href="/atom.xml">
    

    <link rel="canonical" href="https://github.com/zhujiaxiang/zhujiaxiang.github.io/2018/07/31/LeetCodePageOne/"/>

                 
</head>

<body class="home-template no-js">
    <script src="//cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/background-cover.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 Lio&#39;s dream 的主页"><img src="/images/avatar.jpg" width="80" alt="Lio&#39;s dream logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for Lio&#39;s dream">Lio&#39;s dream</a></h1>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description"></p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="Visit the blog" class="blog-button">Blog</a></li>
            
              <li class="navigation__item"><a href="/favourite/1.html">电影</a></li>
            
              <li class="navigation__item"><a href="/favourite/1.html">音乐</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  

  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/zhujiaxiang" title="GitHub" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  
<!-- Twitter -->

  <li class="navigation__item">
    <a href="https://github.com/zhujiaxiang" title="Twitter" target="_blank">
      <i class='social fa fa-twitter'></i>
      <span class="label">Twitter</span>
    </a>
  </li>

  

  <li class="navigation__item">
    <a href="/atom.xml" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>



  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-purple"></div>
  </div> 
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2018-07-31T03:44:12.411Z" class="post-list__meta--date date">2018-07-31</time> &#8226; <span class="post-meta__tags tags">于  </span>
      <span class="page-pv">
       Read <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>
      </span> 
   
    </div>
    <h1 class="post-title">LeetCodePageOne</h1>
  </header>

  <section class="post">
    <h3 id="461-Hamming-Distance"><a href="#461-Hamming-Distance" class="headerlink" title="461. Hamming Distance"></a>461. Hamming Distance</h3><p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different.</p>
<p>Given two integers x and y, calculate the Hamming distance.</p>
<h3 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h3><p>0 ≤ x, y &lt; 231.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: x = 1, y = 4</span><br><span class="line"></span><br><span class="line">Output: 2</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">1   (0 0 0 1)</span><br><span class="line">4   (0 1 0 0)</span><br><span class="line">       ↑   ↑</span><br></pre></td></tr></table></figure>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>求两个数的二进制表示中，不同位数的个数。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>将两个数进行异或</li>
<li>统计异或后的数字中1的个数<h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int hammingDistance(int x, int y) &#123;</span><br><span class="line">        int dist = 0; int n = x^y;  //异或</span><br><span class="line">        while(n)</span><br><span class="line">        &#123;</span><br><span class="line">            ++dist;</span><br><span class="line">            n = n&amp;(n-1);</span><br><span class="line">        &#125;</span><br><span class="line">        return dist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="476-Number-Complement"><a href="#476-Number-Complement" class="headerlink" title="476. Number Complement"></a>476. Number Complement</h3><p>Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.</p>
<p>The above arrows point to positions where the corresponding bits are different.</p>
<h4 id="Note-1"><a href="#Note-1" class="headerlink" title="Note:"></a>Note:</h4><p>The given integer is guaranteed to fit within the range of a 32-bit signed integer.<br>You could assume no leading zero bit in the integer’s binary representation.</p>
<h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2</span><br></pre></td></tr></table></figure>
<h4 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 1</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.</span><br></pre></td></tr></table></figure>
<h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>取一个正整数的二进制表达的反</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol>
<li>制作一个mask 将正整数的二进制位数对应的位数 置为0；</li>
<li>将正整数取反 与 ~mask(00000000111)作与运算</li>
</ol>
<h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findComplement(int num) &#123;</span><br><span class="line">      unsigned mask = ~0;             //制作mask</span><br><span class="line">        while (num &amp; mask) mask &lt;&lt;= 1;//根据正整数的二进制位数 将mask对应的位数置为0；</span><br><span class="line">        return ~mask &amp; ~num;          //将正整数取反，与mask作与运算</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="190-Reverse-Bits"><a href="#190-Reverse-Bits" class="headerlink" title="190. Reverse Bits"></a>190. Reverse Bits</h3><p>Reverse bits of a given 32 bits unsigned integer.</p>
<h4 id="For-example"><a href="#For-example" class="headerlink" title="For example"></a>For example</h4><p>given<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input 43261596 (represented in binary as 00000010100101000001111010011100)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">, return 964176192 (represented in binary as 00111001011110000010100101000000).</span><br></pre></td></tr></table></figure>
<h4 id="Follow-up"><a href="#Follow-up" class="headerlink" title="Follow up:"></a>Follow up:</h4><p>If this function is called many times, how would you optimize it?</p>
<h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><p>反转比特</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol>
<li>每次取最后一位加入result</li>
<li>再将imput右移抛出已加入的数字</li>
</ol>
<h3 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> uint32_t reverseBits(uint32_t input)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t result = 0;</span><br><span class="line">    const uint32_t BITS_OF_BYTES = 8 ;</span><br><span class="line">    for (int i=0; i&lt;sizeof(input)*BITS_OF_BYTES; i++) &#123;</span><br><span class="line">        result = (result &lt;&lt; 1 )|(input &amp; 1);            //result左移空出位置，将input最后一位加入</span><br><span class="line">        input = input &gt;&gt; 1;                            //input右移</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="500-Keyboard-Row"><a href="#500-Keyboard-Row" class="headerlink" title="500. Keyboard Row"></a>500. Keyboard Row</h3><p>Given a List of words, return the words that can be typed using letters of alphabet on only one row’s of American keyboard like the image below.<br><img src="https://leetcode.com/static/images/problemset/keyboard.png" alt="image"></p>
<h4 id="Example-1-1"><a href="#Example-1-1" class="headerlink" title="Example 1:"></a>Example 1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;Hello&quot;, &quot;Alaska&quot;, &quot;Dad&quot;, &quot;Peace&quot;]</span><br><span class="line">Output: [&quot;Alaska&quot;, &quot;Dad&quot;]</span><br></pre></td></tr></table></figure>
<h4 id="Note-2"><a href="#Note-2" class="headerlink" title="Note:"></a>Note:</h4><p>You may use one character in the keyboard more than once.</p>
<p>You may assume the input string will only contain letters of alphabet.</p>
<h4 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h4><p>给你一列表的单词，返回那些只包含美式键盘一行的单词</p>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>查每个单词的第一个字母，将其设为某行，随后遍历每个字母，看是否都在那一行</p>
<h4 id="C-3"><a href="#C-3" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; findWords(std::vector&lt;std::string&gt; &amp;words)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    std::unordered_set&lt;char&gt; set1 = &#123;&apos;q&apos;, &apos;w&apos;, &apos;e&apos;, &apos;r&apos;, &apos;t&apos;, &apos;y&apos;, &apos;u&apos;, &apos;i&apos;, &apos;o&apos;, &apos;p&apos;&#125;;</span><br><span class="line">    std::unordered_set&lt;char&gt; set2 = &#123;&apos;a&apos;, &apos;s&apos;, &apos;d&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;&#125;;</span><br><span class="line">    std::unordered_set&lt;char&gt; set3 = &#123;&apos;z&apos;, &apos;x&apos;, &apos;c&apos;, &apos;v&apos;, &apos;b&apos;, &apos;n&apos;, &apos;m&apos;&#125;;</span><br><span class="line">    std::vector&lt;std::unordered_set&lt;char&gt;&gt; sets = &#123;set1, set2, set3&#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::string&gt; result;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; words.size(); i++) &#123;</span><br><span class="line">        int index = 0, flag = 0;</span><br><span class="line">        if (set1.find(tolower(words[i][0])) != set1.end()) &#123;</span><br><span class="line">            index = 0;</span><br><span class="line">        &#125; else if (set2.find(tolower(words[i][0])) != set2.end()) &#123;</span><br><span class="line">            index = 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            index = 2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::unordered_set&lt;char&gt; tempset = sets[index];</span><br><span class="line"></span><br><span class="line">        for (char a : words[i]) &#123;</span><br><span class="line">            if (tempset.find(tolower(a)) == tempset.end()) &#123;</span><br><span class="line">                flag = 1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (flag == 0) &#123;</span><br><span class="line">            result.push_back(words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h4><p>==using namespace std; or using std::xxxxx；==</p>
<h3 id="412-Fizz-Buzz"><a href="#412-Fizz-Buzz" class="headerlink" title="412. Fizz Buzz"></a>412. Fizz Buzz</h3><p>Write a program that outputs the string representation of numbers from 1 to n.</p>
<p>But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.</p>
<h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">n = 15,</span><br><span class="line"></span><br><span class="line">Return:</span><br><span class="line">[</span><br><span class="line">    &quot;1&quot;,</span><br><span class="line">    &quot;2&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;4&quot;,</span><br><span class="line">    &quot;Buzz&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;7&quot;,</span><br><span class="line">    &quot;8&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;Buzz&quot;,</span><br><span class="line">    &quot;11&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;13&quot;,</span><br><span class="line">    &quot;14&quot;,</span><br><span class="line">    &quot;FizzBuzz&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="问题-4"><a href="#问题-4" class="headerlink" title="问题"></a>问题</h4><p>给一个N 从1到n中的数 放入数组，如果是三的倍数输出Fizz，五的倍数输出Buzz，三五的倍数输出FizzBuzz</p>
<h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>分支判断</p>
<h4 id="C-4"><a href="#C-4" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; fizzBuzz(int n)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;string&gt; a;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        if (i%15==0) &#123;</span><br><span class="line">            a.push_back(&quot;FizzBuzz&quot;);</span><br><span class="line">        &#125;else if (i%5==0)&#123;</span><br><span class="line">            a.push_back(&quot;Buzz&quot;);</span><br><span class="line">        &#125;else if (i%3==0)&#123;</span><br><span class="line">            a.push_back(&quot;Fizz&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            a.push_back(to_string(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="收获-1"><a href="#收获-1" class="headerlink" title="收获"></a>收获</h4><p>==to_string()== int=&gt;string</p>
<h4 id="别人写法"><a href="#别人写法" class="headerlink" title="别人写法"></a>别人写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; fizzBuzz(int n) &#123;</span><br><span class="line">        vector&lt;string&gt; ret_vec(n);</span><br><span class="line">        for(int i=1; i&lt;=n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i%3 == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                ret_vec[i-1] += string(&quot;Fizz&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if(i%5 == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                ret_vec[i-1] += string(&quot;Buzz&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if(ret_vec[i-1] == &quot;&quot;)</span><br><span class="line">            &#123;</span><br><span class="line">                ret_vec[i-1] += to_string(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret_vec;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="344-Reverse-String"><a href="#344-Reverse-String" class="headerlink" title="344. Reverse String"></a>344. Reverse String</h3><p>Write a function that takes a string as input and returns the string reversed.</p>
<h4 id="Example-2"><a href="#Example-2" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given s = &quot;hello&quot;, return &quot;olleh&quot;.</span><br></pre></td></tr></table></figure>
<h3 id="C-5"><a href="#C-5" class="headerlink" title="C++"></a>C++</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">string reverseString(string s) &#123;</span><br><span class="line">    </span><br><span class="line">    if(s==&quot;&quot;)&#123;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125; ;</span><br><span class="line">    string result = &quot;&quot;;</span><br><span class="line">    int length = (int)s.length();</span><br><span class="line">    </span><br><span class="line">    if(length != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = length; i&gt;0; i--) &#123;</span><br><span class="line">            char temp = s[i-1];</span><br><span class="line">            result+=temp;       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="别人写法-1"><a href="#别人写法-1" class="headerlink" title="别人写法"></a>别人写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string reverseString(string s) &#123;</span><br><span class="line">       int i = 0, j = s.size() - 1;</span><br><span class="line">       while(i &lt; j)&#123;</span><br><span class="line">           swap(s[i++], s[j--]); </span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       return s;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="收获-2"><a href="#收获-2" class="headerlink" title="收获"></a>收获</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swap函数</span><br></pre></td></tr></table></figure>
<h3 id="496-Next-Greater-Element-I"><a href="#496-Next-Greater-Element-I" class="headerlink" title="496. Next Greater Element I"></a>496. Next Greater Element I</h3><p>You are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1’s elements in the corresponding places of nums2.</p>
<p>The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number.</p>
<h4 id="Example-1-2"><a href="#Example-1-2" class="headerlink" title="Example 1:"></a>Example 1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [4,1,2], nums2 = [1,3,4,2].</span><br><span class="line">Output: [-1,3,-1]</span><br><span class="line">Explanation:</span><br><span class="line">    For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.</span><br><span class="line">    For number 1 in the first array, the next greater number for it in the second array is 3.</span><br><span class="line">    For number 2 in the first array, there is no next greater number for it in the second array, so output -1.</span><br></pre></td></tr></table></figure>
<h4 id="Example-2-1"><a href="#Example-2-1" class="headerlink" title="Example 2:"></a>Example 2:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [2,4], nums2 = [1,2,3,4].</span><br><span class="line">Output: [3,-1]</span><br><span class="line">Explanation:</span><br><span class="line">    For number 2 in the first array, the next greater number for it in the second array is 3.</span><br><span class="line">    For number 4 in the first array, there is no next greater number for it in the second array, so output -1.</span><br></pre></td></tr></table></figure>
<h4 id="Note-3"><a href="#Note-3" class="headerlink" title="Note:"></a>Note:</h4><p>All elements in nums1 and nums2 are unique.</p>
<p>The length of both nums1 and nums2 would not exceed 1000.</p>
<h3 id="C-6"><a href="#C-6" class="headerlink" title="C++"></a>C++</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; findNums, vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int n = findNums.size();</span><br><span class="line">    int m = nums.size();</span><br><span class="line">    vector&lt;int&gt; result(n);</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;m;j++)&#123;</span><br><span class="line">            if (findNums[i] == nums[j]) &#123;</span><br><span class="line"></span><br><span class="line">                for (int k=j; k&lt;m; k++) &#123;</span><br><span class="line">                    if (nums[k]&gt;findNums[i]) &#123;</span><br><span class="line">                        result[i]=nums[k];</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                if (!result[i]) &#123;</span><br><span class="line">                    result[i]=-1;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                break;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                result[i] = -1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="别人写法-2"><a href="#别人写法-2" class="headerlink" title="别人写法"></a>别人写法</h3><p>通过建立一个键值对，预先保存nums中每个数的nextGreaterElement，随后对其进行查找。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line"> vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; findNums, vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">		unordered_map&lt;int, int&gt; mark;</span><br><span class="line">		deque&lt;int&gt; next;</span><br><span class="line">		for (auto i : nums)&#123;</span><br><span class="line">			while (!next.empty() &amp;&amp; i &gt; next.back())&#123;</span><br><span class="line">				mark[next.back()] = i;</span><br><span class="line">				next.pop_back();</span><br><span class="line">			&#125;</span><br><span class="line">			next.push_back(i);</span><br><span class="line">		&#125;</span><br><span class="line">		vector&lt;int &gt;res;</span><br><span class="line">		for (auto i : findNums)&#123;</span><br><span class="line">			if (mark.find(i) != mark.end())&#123;</span><br><span class="line">				res.push_back(mark[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			else&#123;</span><br><span class="line">				res.push_back(-1);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="463-Island-Perimeter"><a href="#463-Island-Perimeter" class="headerlink" title="463. Island Perimeter"></a>463. Island Perimeter</h3><p>You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn’t have “lakes” (water inside that isn’t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island.</p>
<h4 id="Example-3"><a href="#Example-3" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[[0,1,0,0],</span><br><span class="line"> [1,1,1,0],</span><br><span class="line"> [0,1,0,0],</span><br><span class="line"> [1,1,0,0]]</span><br><span class="line"></span><br><span class="line">Answer: 16</span><br><span class="line">Explanation: The perimeter is the 16 yellow stripes in the image below:</span><br></pre></td></tr></table></figure>
<p><img src="https://leetcode.com/static/images/problemset/island.png" alt="image"></p>
<h4 id="问题-5"><a href="#问题-5" class="headerlink" title="问题"></a>问题</h4><p>0是海1是岛，求岛的边界</p>
<h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>从非边缘行，列开始遍历，遍历到1，count++，检查其左上两个是否也为一，若为1记录为一个repeat，</p>
<h4 id="C-7"><a href="#C-7" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    int repeat = 0;</span><br><span class="line">    for (int i=0; i&lt;grid.size(); i++) &#123;</span><br><span class="line">        for (int j=0; j&lt;grid[i].size(); j++) &#123;</span><br><span class="line">            if (grid[i][j] == 1) &#123;</span><br><span class="line">                count ++;</span><br><span class="line">                if (j!=0 &amp;&amp; grid[i][j-1] == 1) &#123;</span><br><span class="line">                    repeat ++;</span><br><span class="line">                &#125;</span><br><span class="line">                if (i!=0 &amp;&amp; grid[i-1][j] == 1) &#123;</span><br><span class="line">                    repeat ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return count * 4 -repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="收获-3"><a href="#收获-3" class="headerlink" title="收获"></a>收获</h4><p>遍历二维vector的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int i=0; i&lt;grid.size(); i++) </span><br><span class="line">&#123;</span><br><span class="line">        for (int j=0; j&lt;grid[i].size(); j++) </span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="292-Nim-Game"><a href="#292-Nim-Game" class="headerlink" title="292. Nim Game"></a>292. Nim Game</h3><p>You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.</p>
<p>Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.</p>
<p>For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.</p>
<h4 id="Hint"><a href="#Hint" class="headerlink" title="Hint:"></a>Hint:</h4><p>If there are 5 stones in the heap, could you figure out a way to remove the stones such that you will always be the winner?</p>
<h4 id="问题-6"><a href="#问题-6" class="headerlink" title="问题"></a>问题</h4><p>取石头 一个人能取1，2，3块石头，如果你是先手，判断是否能赢</p>
<h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>是4的倍数必输</p>
<h4 id="C-8"><a href="#C-8" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool canWinNim(int n) &#123;</span><br><span class="line">        return (n &amp;0B11) != 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="收获-4"><a href="#收获-4" class="headerlink" title="收获"></a>收获</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(n % 4) != 0 </span><br><span class="line">(n &amp;0B11) != 0;</span><br></pre></td></tr></table></figure>
<h3 id="485-Max-Consecutive-Ones"><a href="#485-Max-Consecutive-Ones" class="headerlink" title="485. Max Consecutive Ones"></a>485. Max Consecutive Ones</h3><p>Given a binary array, find the maximum number of consecutive 1s in this array.</p>
<h4 id="Example-1-3"><a href="#Example-1-3" class="headerlink" title="Example 1:"></a>Example 1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,0,1,1,1]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The first two digits or the last three digits are consecutive 1s.</span><br><span class="line">    The maximum number of consecutive 1s is 3.</span><br></pre></td></tr></table></figure>
<h4 id="Note-4"><a href="#Note-4" class="headerlink" title="Note:"></a>Note:</h4><p>The input array will only contain 0 and 1.</p>
<p>The length of input array is a positive integer and will not exceed 10,000</p>
<h4 id="问题-7"><a href="#问题-7" class="headerlink" title="问题"></a>问题</h4><p>求最长的连续1的数量</p>
<h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p>做一个mark数组标记0的位置，再进行处理</p>
<h4 id="C-9"><a href="#C-9" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int findMaxConsecutiveOnes(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">   vector&lt;int&gt; mark;</span><br><span class="line">   int count = 0;</span><br><span class="line">   mark.push_back(-1);</span><br><span class="line">   for(int i=0;i&lt;nums.size();i++)&#123;</span><br><span class="line">       if (nums[i] == 0) &#123;</span><br><span class="line">           mark.push_back(i);</span><br><span class="line">           count ++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   if(count == 0)&#123;</span><br><span class="line">       return (int)nums.size();</span><br><span class="line">   &#125;</span><br><span class="line">   mark.push_back(nums.size());</span><br><span class="line">   int max = 0;</span><br><span class="line">   for (int j=1; j&lt;mark.size(); j++) &#123;</span><br><span class="line">       if (mark[j]-mark[j-1] -1 &gt;max) &#123;</span><br><span class="line">           max = mark[j]-mark[j-1]-1;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return max;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<h4 id="别人写法-3"><a href="#别人写法-3" class="headerlink" title="别人写法"></a>别人写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int findMaxConsecutiveOnes(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">int max=0,cur=0;</span><br><span class="line">for(int i=0;i&lt;nums.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">if(nums[i]&amp;1)</span><br><span class="line">&#123;</span><br><span class="line">max=max&gt;++cur?max:cur;</span><br><span class="line">&#125;</span><br><span class="line">else cur=0;</span><br><span class="line">&#125;</span><br><span class="line">return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="收获-5"><a href="#收获-5" class="headerlink" title="收获"></a>收获</h4><p>别想太复杂</p>
<h3 id="136-Single-Number"><a href="#136-Single-Number" class="headerlink" title="136. Single Number"></a>136. Single Number</h3><p>Given an array of integers, every element appears twice except for one. Find that single one.</p>
<h4 id="Note-5"><a href="#Note-5" class="headerlink" title="Note:"></a>Note:</h4><p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<h4 id="问题-8"><a href="#问题-8" class="headerlink" title="问题"></a>问题</h4><p>求一个数组中的单个数字，要求线性时间复杂度，无额外空间</p>
<h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p>异或为0</p>
<h4 id="C-10"><a href="#C-10" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">            for(int i=1;i&lt;nums.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[0]=nums[0]^nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return nums[0];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="收获-6"><a href="#收获-6" class="headerlink" title="收获"></a>收获</h4><p>多关注位运算，异或，与，非，反</p>
<h3 id="448-Find-All-Numbers-Disappeared-in-an-Array"><a href="#448-Find-All-Numbers-Disappeared-in-an-Array" class="headerlink" title="448. Find All Numbers Disappeared in an Array"></a>448. Find All Numbers Disappeared in an Array</h3><p>Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.</p>
<p>Find all the elements of [1, n] inclusive that do not appear in this array.</p>
<p>Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.</p>
<h4 id="Example-4"><a href="#Example-4" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[5,6]</span><br></pre></td></tr></table></figure>
<h4 id="问题-9"><a href="#问题-9" class="headerlink" title="问题"></a>问题</h4><p>寻找数组中消失的数字</p>
<h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><p>把数字放到该放的地方，然后找出消失的数字</p>
<h4 id="C-11"><a href="#C-11" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int len = (int)nums.size();</span><br><span class="line">    for (int i=0; i&lt;len; i++) &#123;</span><br><span class="line">        int m = abs(nums[i])-1;</span><br><span class="line">        nums[m]= nums[m]&gt;0?-nums[m]:nums[m];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    for (int i=0; i&lt;len; i++) &#123;</span><br><span class="line">        if(nums[i] &gt; 0) res.push_back(i+1);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="520-Detect-Capital"><a href="#520-Detect-Capital" class="headerlink" title="520. Detect Capital"></a>520. Detect Capital</h3><p>Given a word, you need to judge whether the usage of capitals in it is right or not.</p>
<p>We define the usage of capitals in a word to be right when one of the following cases holds:</p>
<p>All letters in this word are capitals, like “USA”.<br>All letters in this word are not capitals, like “leetcode”.<br>Only the first letter in this word is capital if it has more than one letter, like “Google”.<br>Otherwise, we define that this word doesn’t use capitals in a right way.</p>
<h4 id="Example-1-4"><a href="#Example-1-4" class="headerlink" title="Example 1:"></a>Example 1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;USA&quot;</span><br><span class="line">Output: True</span><br></pre></td></tr></table></figure>
<h4 id="Example-2-2"><a href="#Example-2-2" class="headerlink" title="Example 2:"></a>Example 2:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;FlaG&quot;</span><br><span class="line">Output: False</span><br></pre></td></tr></table></figure>
<h4 id="Note-6"><a href="#Note-6" class="headerlink" title="Note:"></a>Note:</h4><p>The input will be a non-empty word consisting of uppercase and lowercase latin letters.</p>
<h4 id="问题-10"><a href="#问题-10" class="headerlink" title="问题"></a>问题</h4><p>看string是否符合标准大写规则</p>
<h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><p>分支判断</p>
<h4 id="C-12"><a href="#C-12" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">bool detectCapitalUse(string word) &#123;</span><br><span class="line">    char c = word[0];</span><br><span class="line">    if (!isupper(c)) &#123;</span><br><span class="line">        for (auto a:word) &#123;</span><br><span class="line">            if (isupper(a)) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        if (isupper(word[1])) &#123;</span><br><span class="line">            for (auto a:word) &#123;</span><br><span class="line">                if (islower(a)) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            for(int i = 2;i&lt;word.length();i++)&#123;</span><br><span class="line">                if (isupper(word[i])) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="别人写法-4"><a href="#别人写法-4" class="headerlink" title="别人写法"></a>别人写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public boolean detectCapitalUse(String word) &#123;</span><br><span class="line">       int cnt = 0;</span><br><span class="line">       for(char c: word.toCharArray()) if(&apos;Z&apos; - c &gt;= 0) cnt++;</span><br><span class="line">       return ((cnt==0 || cnt==word.length()) || (cnt==1 &amp;&amp; &apos;Z&apos; - word.charAt(0)&gt;=0));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="收获-7"><a href="#收获-7" class="headerlink" title="收获"></a>收获</h4><p>通过ASC码判断，大写字母的ASC码比小写字母小。</p>
<h3 id="104-Maximum-Depth-of-Binary-Tree"><a href="#104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104. Maximum Depth of Binary Tree"></a>104. Maximum Depth of Binary Tree</h3><h4 id="问题-11"><a href="#问题-11" class="headerlink" title="问题"></a>问题</h4><p>求树的最大深度</p>
<h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><p>深度优先||广度优先</p>
<h4 id="C-13"><a href="#C-13" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">深度优先</span><br><span class="line">int maxDepth(TreeNode* root) &#123;</span><br><span class="line">    return root == NULL ? 0 :max(maxDepth(root-&gt;left), maxDepth(root-&gt;right))+1;</span><br><span class="line">&#125;</span><br><span class="line">广度优先</span><br><span class="line">int maxDepth(TreeNode *root)</span><br><span class="line">&#123;</span><br><span class="line">    if(root == NULL)</span><br><span class="line">        return 0;</span><br><span class="line">    </span><br><span class="line">    int res = 0;</span><br><span class="line">    queue&lt;TreeNode *&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        ++ res;</span><br><span class="line">        for(int i = 0, n = q.size(); i &lt; n; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode *p = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            </span><br><span class="line">            if(p -&gt; left != NULL)</span><br><span class="line">                q.push(p -&gt; left);</span><br><span class="line">            if(p -&gt; right != NULL)</span><br><span class="line">                q.push(p -&gt; right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="389-Find-the-Difference"><a href="#389-Find-the-Difference" class="headerlink" title="389. Find the Difference"></a>389. Find the Difference</h3><h4 id="问题-12"><a href="#问题-12" class="headerlink" title="问题"></a>问题</h4><p>寻找两个字符串不同的字符</p>
<h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4><p>位运算 异或能找出单个不同的字符</p>
<h4 id="C-14"><a href="#C-14" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">char findTheDifference(string s, string t) &#123;</span><br><span class="line"></span><br><span class="line">    char res = &apos;\0&apos;;</span><br><span class="line">    for (char a:s) &#123;</span><br><span class="line">        res = res^a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (char b:t) &#123;</span><br><span class="line">        res = res^b;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res;</span><br><span class="line">    </span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="收获-8"><a href="#收获-8" class="headerlink" title="收获"></a>收获</h4><p>异或找不同</p>
<h3 id="371-Sum-of-Two-Integers"><a href="#371-Sum-of-Two-Integers" class="headerlink" title="371. Sum of Two Integers"></a>371. Sum of Two Integers</h3><p>Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.</p>
<h4 id="Example-5"><a href="#Example-5" class="headerlink" title="Example:"></a>Example:</h4><p>Given a = 1 and b = 2, return 3.</p>
<h4 id="问题-13"><a href="#问题-13" class="headerlink" title="问题"></a>问题</h4><p>在不使用+ -的情况下 实现加法</p>
<h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h4><p>通过异或来实现0+1或1+0，通过与并左移实现进位</p>
<h4 id="C-15"><a href="#C-15" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int getSum(int a, int b) &#123;</span><br><span class="line">    int sum = a;</span><br><span class="line">    while (b!=0) &#123;</span><br><span class="line">        sum = a^b;</span><br><span class="line">        b = (a&amp;b)&lt;&lt;1;</span><br><span class="line">        a = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="收获-9"><a href="#收获-9" class="headerlink" title="收获"></a>收获</h4><p>可以通过异或来实现0+1或1+0，通过与+左移实现进位</p>
<h3 id="226-Invert-Binary-Tree"><a href="#226-Invert-Binary-Tree" class="headerlink" title="226. Invert Binary Tree"></a>226. Invert Binary Tree</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Invert a binary tree.</span><br><span class="line"></span><br><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  2     7</span><br><span class="line"> / \   / \</span><br><span class="line">1   3 6   9</span><br><span class="line">to</span><br><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  7     2</span><br><span class="line"> / \   / \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>
<h4 id="问题-14"><a href="#问题-14" class="headerlink" title="问题"></a>问题</h4><p>翻转二叉树</p>
<h4 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h4><p>递归，非递归（广度优先）</p>
<h4 id="C-16"><a href="#C-16" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">递归</span><br><span class="line">TreeNode* invertTree(TreeNode* root) &#123;</span><br><span class="line">              if(root == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (root) &#123;</span><br><span class="line">        TreeNode *temp = root-&gt;left;</span><br><span class="line">        root-&gt;left = root-&gt;right;</span><br><span class="line">        root-&gt;right = temp;</span><br><span class="line">        </span><br><span class="line">        if(root-&gt;left !=NULL)&#123;</span><br><span class="line">            invertTree(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        if (root-&gt;right !=NULL) &#123;</span><br><span class="line">            invertTree(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return root;</span><br><span class="line">    &#125;</span><br><span class="line">非递归</span><br><span class="line">TreeNode *invertTree(TreeNode *root)</span><br><span class="line">&#123;</span><br><span class="line">    stack&lt;TreeNode *&gt; stack;</span><br><span class="line">    stack.push(root);</span><br><span class="line">    while (!stack.empty()) &#123;</span><br><span class="line">        TreeNode *p = stack.top();</span><br><span class="line">        stack.pop();</span><br><span class="line">        if (p) &#123;</span><br><span class="line">            stack.push(root-&gt;left);</span><br><span class="line">            stack.push(root-&gt;right);</span><br><span class="line">            swap(root-&gt;left, root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="收获-10"><a href="#收获-10" class="headerlink" title="收获"></a>收获</h4><p>swap函数</p>
<h3 id="258-Add-Digits"><a href="#258-Add-Digits" class="headerlink" title="258. Add Digits"></a>258. Add Digits</h3><p>Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.</p>
<h4 id="For-example-1"><a href="#For-example-1" class="headerlink" title="For example:"></a>For example:</h4><p>Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.</p>
<h4 id="Follow-up-1"><a href="#Follow-up-1" class="headerlink" title="Follow up:"></a>Follow up:</h4><p>Could you do it without any loop/recursion in O(1) runtime?</p>
<h4 id="问题-15"><a href="#问题-15" class="headerlink" title="问题"></a>问题</h4><p>38-》3+8=11》1+1》2  一个数，各位数相加，直至只剩一位数</p>
<h4 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h4><p><a href="https://www.zhihu.com/question/30972581" target="_blank" rel="noopener">数根</a></p>
<h4 id="C-17"><a href="#C-17" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int addDigits(int num) &#123;</span><br><span class="line">    return 1+(num-1)%9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="收获-11"><a href="#收获-11" class="headerlink" title="收获"></a>收获</h4><p>12345 % 9 = (1 + 2 + 3 + 4 +5 ) % 9 </p>
<h3 id="492-Construct-the-Rectangle"><a href="#492-Construct-the-Rectangle" class="headerlink" title="492. Construct the Rectangle"></a>492. Construct the Rectangle</h3><p>For a web developer, it is very important to know how to design a web page’s size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. The area of the rectangular web page you designed must equal to the given target area.</span><br><span class="line"></span><br><span class="line">2. The width W should not be larger than the length L, which means L &gt;= W.</span><br><span class="line"></span><br><span class="line">3. The difference between length L and width W should be as small as possible.</span><br><span class="line">You need to output the length L and the width W of the web page you designed in sequence.</span><br></pre></td></tr></table></figure>
<h4 id="Example-6"><a href="#Example-6" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: [2, 2]</span><br><span class="line">Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. </span><br><span class="line">But according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.</span><br></pre></td></tr></table></figure>
<h4 id="Note-7"><a href="#Note-7" class="headerlink" title="Note:"></a>Note:</h4><p>The given area won’t exceed 10,000,000 and is a positive integer<br>The web page’s width and length you designed must be positive integers</p>
<h4 id="问题-16"><a href="#问题-16" class="headerlink" title="问题"></a>问题</h4><p>给定一个正方形面积，求出符合要求的一组长款</p>
<h4 id="收获-12"><a href="#收获-12" class="headerlink" title="收获"></a>收获</h4><p>时间复杂度，的优化</p>
<h4 id="C-18"><a href="#C-18" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">写法1：99ms</span><br><span class="line">vector&lt;int&gt; constructRectangle(int area) &#123;</span><br><span class="line">    </span><br><span class="line">    int l = sqrt(area);</span><br><span class="line">    for(int i = l;i&lt;=area;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (area%i==0) &#123;</span><br><span class="line">            l=i;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int w = area/l;</span><br><span class="line">    </span><br><span class="line">    if(w&gt;l)&#123;</span><br><span class="line">        swap(w,l);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; result = &#123;l,w&#125;;</span><br><span class="line">    </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">更新写法2：3ms</span><br><span class="line">vector&lt;int&gt; constructRectangle(int area) &#123;</span><br><span class="line">    </span><br><span class="line">    int w ;</span><br><span class="line">    for(int i = 1;i*i&lt;=area;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (area%i==0) &#123;</span><br><span class="line">            w=i;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; result = &#123;area/w,w&#125;;</span><br><span class="line">    </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="收获-13"><a href="#收获-13" class="headerlink" title="收获"></a>收获</h4><p>不用系统函数，想办法替代</p>
<h3 id="283-Move-Zeroes"><a href="#283-Move-Zeroes" class="headerlink" title="283. Move Zeroes"></a>283. Move Zeroes</h3><p>Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p>For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].</p>
<h4 id="Note-8"><a href="#Note-8" class="headerlink" title="Note:"></a>Note:</h4><p>You must do this in-place without making a copy of the array.<br>Minimize the total number of operations.</p>
<h4 id="问题-17"><a href="#问题-17" class="headerlink" title="问题"></a>问题</h4><p>将数组中的0移动到数组末尾</p>
<h4 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h4><p>遇到非0就覆盖原数组，最后再将0添上</p>
<h4 id="C-19"><a href="#C-19" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int j = 0;</span><br><span class="line">    for (int i=0; i&lt;nums.size(); i++) &#123;</span><br><span class="line">        if (nums[i]!=0) &#123;</span><br><span class="line">            nums[j++]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (; j&lt;nums.size(); j++) &#123;</span><br><span class="line">        nums[j] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="506-Relative-Ranks"><a href="#506-Relative-Ranks" class="headerlink" title="506. Relative Ranks"></a>506. Relative Ranks</h3><p>Given scores of N athletes, find their relative ranks and the people with the top three highest scores, who will be awarded medals: “Gold Medal”, “Silver Medal” and “Bronze Medal”.</p>
<h4 id="Example-1-5"><a href="#Example-1-5" class="headerlink" title="Example 1:"></a>Example 1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [5, 4, 3, 2, 1]</span><br><span class="line">Output: [&quot;Gold Medal&quot;, &quot;Silver Medal&quot;, &quot;Bronze Medal&quot;, &quot;4&quot;, &quot;5&quot;]</span><br><span class="line">Explanation: The first three athletes got the top three highest scores, so they got &quot;Gold Medal&quot;, &quot;Silver Medal&quot; and &quot;Bronze Medal&quot;. </span><br><span class="line">For the left two athletes, you just need to output their relative ranks according to their scores.</span><br></pre></td></tr></table></figure>
<h4 id="Note-9"><a href="#Note-9" class="headerlink" title="Note:"></a>Note:</h4><p>N is a positive integer and won’t exceed 10,000.<br>All the scores of athletes are guaranteed to be unique.</p>
<h4 id="问题-18"><a href="#问题-18" class="headerlink" title="问题"></a>问题</h4><p>根据数组中的得，输出其对应的排名    </p>
<h4 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a>思路</h4><p>利用C++ map的递增特性，进行输出</p>
<h4 id="C-20"><a href="#C-20" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; findRelativeRanks(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line"></span><br><span class="line">    map&lt;int,int&gt; mp;</span><br><span class="line">    </span><br><span class="line">    for (int i=0; i&lt;nums.size(); i++) &#123;</span><br><span class="line">        mp[nums[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;string&gt; res(nums.size(),&quot;&quot;);</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    for (map&lt;int,int&gt;::reverse_iterator it = mp.rbegin(); it!=mp.rend(); it++,cnt++) &#123;</span><br><span class="line">        if (cnt== 0) &#123;</span><br><span class="line">            res[it-&gt;second] = &quot;Gold Medal&quot;;</span><br><span class="line">        &#125;else if (cnt==1)&#123;</span><br><span class="line">            res[it-&gt;second] = &quot;Silver Medal&quot;;</span><br><span class="line">        &#125;else if (cnt==2)&#123;</span><br><span class="line">            res[it-&gt;second] = &quot;Bronze Medal&quot;;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            res[it-&gt;second] = to_string(cnt+1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="收获-14"><a href="#收获-14" class="headerlink" title="收获"></a>收获</h4><p>C++ map是递增的，it—&gt;first是key it-&gt;second是value，倒序遍历迭代器的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(map&lt;int,int&gt;::reverse_iterator it=mp.rbegin();it!+mp.rend();it++)</span><br></pre></td></tr></table></figure>
<h3 id="530-Minimum-Absolute-Difference-in-BST"><a href="#530-Minimum-Absolute-Difference-in-BST" class="headerlink" title="530. Minimum Absolute Difference in BST"></a>530. Minimum Absolute Difference in BST</h3><p>Given a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.</p>
<h4 id="Example-7"><a href="#Example-7" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     3</span><br><span class="line">    /</span><br><span class="line">   2</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h4 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation:"></a>Explanation:</h4><p>The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).<br>Note: There are at least two nodes in this BST.</p>
<h4 id="问题-19"><a href="#问题-19" class="headerlink" title="问题"></a>问题</h4><p>求二叉搜索树中，求两个结点绝对值相差最小的值</p>
<h4 id="思路-18"><a href="#思路-18" class="headerlink" title="思路"></a>思路</h4><p>中序遍历出的二叉搜索树是有序递增的，在这个有序的队列中求最小值</p>
<h4 id="C-21"><a href="#C-21" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> public:void inorderTraverse(TreeNode* root, int&amp; val, int&amp; min_dif) &#123;</span><br><span class="line">    if (root-&gt;left != NULL) inorderTraverse(root-&gt;left, val, min_dif);</span><br><span class="line">    if (val &gt;= 0) min_dif = min(min_dif, root-&gt;val - val);</span><br><span class="line">    val = root-&gt;val;</span><br><span class="line">    if (root-&gt;right != NULL) inorderTraverse(root-&gt;right, val, min_dif);</span><br><span class="line">&#125;</span><br><span class="line">public:int getMinimumDifference(TreeNode* root) &#123;</span><br><span class="line">    auto min_dif = INT_MAX, val = -1;</span><br><span class="line">    inorderTraverse(root, val, min_dif);</span><br><span class="line">    return min_dif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="收获-15"><a href="#收获-15" class="headerlink" title="收获"></a>收获</h4><p>中序遍历二叉搜索树是有序的</p>
<h3 id="167-Two-Sum-II-Input-array-is-sorted"><a href="#167-Two-Sum-II-Input-array-is-sorted" class="headerlink" title="167. Two Sum II - Input array is sorted"></a>167. Two Sum II - Input array is sorted</h3><p>Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.</p>
<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p>
<p>You may assume that each input would have exactly one solution and you may not use the same element twice.</p>
<h4 id="Input"><a href="#Input" class="headerlink" title="Input:"></a>Input:</h4><p>numbers={2, 7, 11, 15}, target=9</p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output:"></a>Output:</h4><p>index1=1, index2=2</p>
<h4 id="问题-20"><a href="#问题-20" class="headerlink" title="问题"></a>问题</h4><p>给一个数组，给一个目标，找出相加为目标数的两个数在数组中的位置</p>
<h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>一左一右两个指针， while</p>
<h4 id="C-22"><a href="#C-22" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;</span><br><span class="line">    </span><br><span class="line">    int r = (int)numbers.size() - 1;</span><br><span class="line">    </span><br><span class="line">    int l = 0;</span><br><span class="line">    </span><br><span class="line">    while (l&lt;r) &#123;</span><br><span class="line">        if (numbers[l] + numbers[r] == target) &#123;</span><br><span class="line">          vector&lt;int&gt; res&#123;l+1,r+1&#125;;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;else if(numbers[l] + numbers[r] &gt; target)&#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;else if(numbers[l] + numbers[r] &lt; target)&#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; fail;</span><br><span class="line">    return fail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="521-Longest-Uncommon-Subsequence-I"><a href="#521-Longest-Uncommon-Subsequence-I" class="headerlink" title="521. Longest Uncommon Subsequence I"></a>521. Longest Uncommon Subsequence I</h3><p>Given a group of two strings, you need to find the longest uncommon subsequence of this group of two strings. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings.</p>
<p>A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.</p>
<p>The input will be two strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn’t exist, return -1.</p>
<h4 id="Example-1-6"><a href="#Example-1-6" class="headerlink" title="Example 1:"></a>Example 1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;aba&quot;, &quot;cdc&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The longest uncommon subsequence is &quot;aba&quot; (or &quot;cdc&quot;), </span><br><span class="line">because &quot;aba&quot; is a subsequence of &quot;aba&quot;, </span><br><span class="line">but not a subsequence of any other strings in the group of two strings.</span><br></pre></td></tr></table></figure>
<h4 id="Note-10"><a href="#Note-10" class="headerlink" title="Note:"></a>Note:</h4><p>Both strings’ lengths will not exceed 100.<br>Only letters from a ~ z will appear in input strings.</p>
<h4 id="问题-21"><a href="#问题-21" class="headerlink" title="问题"></a>问题</h4><p>两个字符串中最长的字符串是否是第二个字符串的子串，如果是则返回-1，否做返回其长度</p>
<h4 id="C-23"><a href="#C-23" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int findLUSlength(string a, string b) &#123;</span><br><span class="line">    </span><br><span class="line">    if (a.size() == b.size()) &#123;</span><br><span class="line">        if (a==b) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return (int)a.size();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return (int)max(a.size(), b.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="455-Assign-Cookies"><a href="#455-Assign-Cookies" class="headerlink" title="455. Assign Cookies"></a>455. Assign Cookies</h3><p>Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj &gt;= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.</p>
<h4 id="Note-11"><a href="#Note-11" class="headerlink" title="Note:"></a>Note:</h4><p>You may assume the greed factor is always positive.<br>You cannot assign more than one cookie to one child.</p>
<h4 id="Example-1-7"><a href="#Example-1-7" class="headerlink" title="Example 1:"></a>Example 1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3], [1,1]</span><br><span class="line"></span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. </span><br><span class="line">And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.</span><br><span class="line">You need to output 1.</span><br></pre></td></tr></table></figure>
<h4 id="Example-2-3"><a href="#Example-2-3" class="headerlink" title="Example 2:"></a>Example 2:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2], [1,2,3]</span><br><span class="line"></span><br><span class="line">Output: 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. </span><br><span class="line">You have 3 cookies and their sizes are big enough to gratify all of the children, </span><br><span class="line">You need to output 2.</span><br></pre></td></tr></table></figure>
<h4 id="问题-22"><a href="#问题-22" class="headerlink" title="问题"></a>问题</h4><p>给小孩分曲奇，两个数组<br>第一个是小孩的需求数组【1，2，3】，代表有3个小孩，分别要1，2，3大小的曲奇<br>第二个是自己拥有的曲奇数组【1，2】代表有2个曲奇，大小分别为1，2</p>
<h4 id="思路-19"><a href="#思路-19" class="headerlink" title="思路"></a>思路</h4><p>贪心算法，先对两个数组进行递增排序，随后开始比较，作一个关于饼干数组的循环，如果遇到合适的小孩，则分配给他，然后对下一个下小孩进行分析</p>
<h4 id="C-24"><a href="#C-24" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123;</span><br><span class="line">    sort(g.begin(),g.end());</span><br><span class="line">    sort(s.begin(), s.end());</span><br><span class="line">    </span><br><span class="line">    int i=0,j=0;</span><br><span class="line">    </span><br><span class="line">    for (; i &lt; g.size()&amp;&amp; j &lt; s.size(); j++) &#123;</span><br><span class="line">        if (g[i]&lt;=s[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="收获-16"><a href="#收获-16" class="headerlink" title="收获"></a>收获</h4><p>贪心算法，sort函数</p>
<h3 id="453-Minimum-Moves-to-Equal-Array-Elements"><a href="#453-Minimum-Moves-to-Equal-Array-Elements" class="headerlink" title="453. Minimum Moves to Equal Array Elements"></a>453. Minimum Moves to Equal Array Elements</h3><p>Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1.</p>
<h4 id="Example-8"><a href="#Example-8" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[1,2,3]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h4 id="Explanation-1"><a href="#Explanation-1" class="headerlink" title="Explanation:"></a>Explanation:</h4><p>Only three moves are needed (remember each move increments two elements):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3]  =&gt;  [2,3,3]  =&gt;  [3,4,3]  =&gt;  [4,4,4]</span><br></pre></td></tr></table></figure>
<h4 id="问题-23"><a href="#问题-23" class="headerlink" title="问题"></a>问题</h4><p>给一组n个数，每次只能进行n-1个数的+1操作，问将他们都变为相同的数字最少需要几步。</p>
<h4 id="思路-20"><a href="#思路-20" class="headerlink" title="思路"></a>思路</h4><p>（min+k）<em>n = sum+k</em>(n-1)<br>k = sum - min*n</p>
<h4 id="C-25"><a href="#C-25" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int minMoves(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    </span><br><span class="line">    if (nums.size()&lt;=1) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        int sum=0,minimum=INT_MAX;</span><br><span class="line">        for (int i=0; i&lt;nums.size(); i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            minimum = min(minimum,nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        int res = sum-(int)(minimum*nums.size());</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="别人写法-5"><a href="#别人写法-5" class="headerlink" title="别人写法"></a>别人写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int minMoves(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    return accumulate(begin(nums), end(nums), 0L) - nums.size() * *min_element(begin(nums), end(nums));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="收获-17"><a href="#收获-17" class="headerlink" title="收获"></a>收获</h4><p>列出等式，找规律 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;numeric&gt;</span><br><span class="line">int sum = accumulate(begin(nums), end(nums), 0);</span><br><span class="line">min_element(begin(nums), end(nums));</span><br></pre></td></tr></table></figure>
<h3 id="383-Ransom-Note"><a href="#383-Ransom-Note" class="headerlink" title="383. Ransom Note"></a>383. Ransom Note</h3><p>Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false.</p>
<p>Each letter in the magazine string can only be used once in your ransom note.</p>
<h4 id="Note-12"><a href="#Note-12" class="headerlink" title="Note:"></a>Note:</h4><p>You may assume that both strings contain only lowercase letters.</p>
<p>canConstruct(“a”, “b”) -&gt; false<br>canConstruct(“aa”, “ab”) -&gt; false<br>canConstruct(“aa”, “aab”) -&gt; true</p>
<h4 id="问题-24"><a href="#问题-24" class="headerlink" title="问题"></a>问题</h4><p>给两个数组，如果能用第二个数组中的元素构成第一个数组，则返回true</p>
<h4 id="思路-21"><a href="#思路-21" class="headerlink" title="思路"></a>思路</h4><p>对数组2的每一个字母进行计数+1，计数完后再对数组1对应进行计数-1，如果有数计数&lt;0，则返回false，否则则返回true</p>
<h4 id="C-26"><a href="#C-26" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bool canConstruct(string ransomNote, string magazine) &#123;</span><br><span class="line">    vector&lt;int&gt; vec(26,0);</span><br><span class="line">    </span><br><span class="line">    for (int i=0; i&lt;magazine.size(); i++) &#123;</span><br><span class="line">        ++vec[magazine[i]-&apos;a&apos;];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int j=0; j&lt;ransomNote.size(); j++) &#123;</span><br><span class="line">        if (--vec[ransomNote[j]-&apos;a&apos;]&lt;0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="收获-18"><a href="#收获-18" class="headerlink" title="收获"></a>收获</h4><p>一种比较的思路</p>
<h3 id="349-Intersection-of-Two-Arrays"><a href="#349-Intersection-of-Two-Arrays" class="headerlink" title="349. Intersection of Two Arrays"></a>349. Intersection of Two Arrays</h3><p>Given two arrays, write a function to compute their intersection.</p>
<h4 id="Example-9"><a href="#Example-9" class="headerlink" title="Example:"></a>Example:</h4><p>Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].</p>
<h4 id="Note-13"><a href="#Note-13" class="headerlink" title="Note:"></a>Note:</h4><p>Each element in the result must be unique.<br>The result can be in any order.<br>Subscribe to see which companies asked this question.</p>
<h4 id="问题-25"><a href="#问题-25" class="headerlink" title="问题"></a>问题</h4><p>给2个数组，找出共同的元素</p>
<h4 id="思路-22"><a href="#思路-22" class="headerlink" title="思路"></a>思路</h4><p>比较，去除重复元素 使用unique</p>
<h4 id="C-27"><a href="#C-27" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">    if(nums1.size()&lt;=0||nums2.size()&lt;=0)</span><br><span class="line">    &#123;</span><br><span class="line">        return vector&lt;int&gt;&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    sort(nums1.begin(),nums1.end());</span><br><span class="line">    sort(nums2.begin(),nums2.end());</span><br><span class="line">    int i=0,j=0;</span><br><span class="line">    for (; i&lt;nums1.size()&amp;&amp;j&lt;nums2.size(); j++) &#123;</span><br><span class="line">        if (nums1[i]==nums2[j]) &#123;</span><br><span class="line">            res.push_back(nums1[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;else if (nums1[i]&lt;nums2[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt;::iterator new_end;</span><br><span class="line">    new_end=unique(res.begin(),res.end());</span><br><span class="line">    res.erase(new_end, res.end());</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="收获-19"><a href="#收获-19" class="headerlink" title="收获"></a>收获</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">去除重复元素</span><br><span class="line"></span><br><span class="line">new_end=unique(res.begin(),res.end());</span><br><span class="line">res.erase(new_end, res.end());</span><br></pre></td></tr></table></figure>
<h3 id="404-Sum-of-Left-Leaves"><a href="#404-Sum-of-Left-Leaves" class="headerlink" title="404. Sum of Left Leaves"></a>404. Sum of Left Leaves</h3><p>Find the sum of all left leaves in a given binary tree.</p>
<h4 id="Example-10"><a href="#Example-10" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.</p>
<h4 id="问题-26"><a href="#问题-26" class="headerlink" title="问题"></a>问题</h4><p>统计一棵树的左叶子和</p>
<h4 id="思路-23"><a href="#思路-23" class="headerlink" title="思路"></a>思路</h4><p>递归</p>
<h4 id="C-28"><a href="#C-28" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int sumOfLeftLeaves(TreeNode* root) &#123;</span><br><span class="line">    </span><br><span class="line">    if(!root)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    if (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) &#123;</span><br><span class="line">        return root-&gt;left-&gt;val + sumOfLeftLeaves(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return sumOfLeftLeaves(root-&gt;left) + sumOfLeftLeaves(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="收获-20"><a href="#收获-20" class="headerlink" title="收获"></a>收获</h4><p>从最小的一部分观察，制定递归策略</p>
<h3 id="122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122. Best Time to Buy and Sell Stock II"></a>122. Best Time to Buy and Sell Stock II</h3><p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<h4 id="问题-27"><a href="#问题-27" class="headerlink" title="问题"></a>问题</h4><p>给一个数组，数组i代表天数，a[i-1]代表当天股票价值，问怎么样才能获取最大值？</p>
<h4 id="思路-24"><a href="#思路-24" class="headerlink" title="思路"></a>思路</h4><p>累加差值，如果遇到下跌的天数就跳过</p>
<h4 id="C-29"><a href="#C-29" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int maxProfit(vector&lt;int&gt; &amp;prices)</span><br><span class="line">&#123;</span><br><span class="line">    if (prices.size() == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int maximum = 0;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; prices.size()-1; i++) &#123;</span><br><span class="line">       </span><br><span class="line">        if (prices[i] &lt; prices[i+1]) &#123;</span><br><span class="line">            maximum = maximum + prices[i+1]-prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return maximum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="别人的写法"><a href="#别人的写法" class="headerlink" title="别人的写法"></a>别人的写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int maxProfit(vector&lt;int&gt; &amp;prices) &#123;</span><br><span class="line">    int ret = 0;</span><br><span class="line">    for (size_t p = 1; p &lt; prices.size(); ++p) </span><br><span class="line">      ret += max(prices[p] - prices[p - 1], 0);    </span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="收获-21"><a href="#收获-21" class="headerlink" title="收获"></a>收获</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (prices[i] &lt; prices[i+1]) </span><br><span class="line">&#123;</span><br><span class="line">     maximum = maximum + prices[i+1]-prices[i];</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"> ret += max(prices[p] - prices[p - 1], 0);</span><br></pre></td></tr></table></figure>
<h3 id="387-First-Unique-Character-in-a-String"><a href="#387-First-Unique-Character-in-a-String" class="headerlink" title="387. First Unique Character in a String"></a>387. First Unique Character in a String</h3><p>Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1.</p>
<h4 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;leetcode&quot;</span><br><span class="line">return 0.</span><br><span class="line"></span><br><span class="line">s = &quot;loveleetcode&quot;,</span><br><span class="line">return 2.</span><br></pre></td></tr></table></figure>
<h4 id="问题-28"><a href="#问题-28" class="headerlink" title="问题"></a>问题</h4><p>求string中第一个不重复的字符的下标</p>
<h4 id="思路-25"><a href="#思路-25" class="headerlink" title="思路"></a>思路</h4><p>使用map将string按字符一个个存入map，并count</p>
<h4 id="C-30"><a href="#C-30" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int firstUniqChar(string s) &#123;</span><br><span class="line">    unordered_map&lt;char, int&gt; map;</span><br><span class="line">    </span><br><span class="line">    for(auto c:s)</span><br><span class="line">    &#123;</span><br><span class="line">        map[c]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i&lt; s.size(); i++) &#123;</span><br><span class="line">        if(map[s[i]] - 1 ==0)</span><br><span class="line">        &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="收获-22"><a href="#收获-22" class="headerlink" title="收获"></a>收获</h4><p>多用键值对，通过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i&lt; s.size(); i++) &#123;</span><br><span class="line">        if(map[s[i]] - 1 ==0)</span><br><span class="line">        &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>能实现按顺序查找第一个不重复的字符。</p>
<h3 id="122-Best-Time-to-Buy-and-Sell-Stock-II-1"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II-1" class="headerlink" title="122. Best Time to Buy and Sell Stock II"></a>122. Best Time to Buy and Sell Stock II</h3><p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<h4 id="问题-29"><a href="#问题-29" class="headerlink" title="问题"></a>问题</h4><p>给定一个数组 下标为天数，各个元素为当天股票价格，球可获利的最大值</p>
<h4 id="思路-26"><a href="#思路-26" class="headerlink" title="思路"></a>思路</h4><p>累加</p>
<h4 id="C-31"><a href="#C-31" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int maxProfit(vector&lt;int&gt; &amp;prices) &#123;</span><br><span class="line">    int ret = 0;</span><br><span class="line">    for (size_t p = 1; p &lt; prices.size(); ++p) </span><br><span class="line">      ret += max(prices[p] - prices[p - 1], 0);    </span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="171-Excel-Sheet-Column-Number"><a href="#171-Excel-Sheet-Column-Number" class="headerlink" title="171. Excel Sheet Column Number"></a>171. Excel Sheet Column Number</h3><p>Given a column title as appear in an Excel sheet, return its corresponding column number.</p>
<h4 id="For-example-2"><a href="#For-example-2" class="headerlink" title="For example:"></a>For example:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; 1</span><br><span class="line">B -&gt; 2</span><br><span class="line">C -&gt; 3</span><br><span class="line">...</span><br><span class="line">Z -&gt; 26</span><br><span class="line">AA -&gt; 27</span><br><span class="line">AB -&gt; 28</span><br></pre></td></tr></table></figure>
<h4 id="问题-30"><a href="#问题-30" class="headerlink" title="问题"></a>问题</h4><p>类似于Excel的列标题，求其代表的数字</p>
<h4 id="思路-27"><a href="#思路-27" class="headerlink" title="思路"></a>思路</h4><p>按位数分析累加</p>
<h4 id="C-32"><a href="#C-32" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int titleToNumber(string s) &#123;</span><br><span class="line">    </span><br><span class="line">    int res = 0;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; s.size(); res = res*26 + s[i] - &apos;A&apos; + 1 , i++ ) ;</span><br><span class="line">    </span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="237-Delete-Node-in-a-Linked-Lis"><a href="#237-Delete-Node-in-a-Linked-Lis" class="headerlink" title="237. Delete Node in a Linked Lis"></a>237. Delete Node in a Linked Lis</h3><p>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.</p>
<p>Supposed the linked list is 1 -&gt; 2 -&gt; 3 -&gt; 4 and you are given the third node with value 3, the linked list should become 1 -&gt; 2 -&gt; 4 after calling your function.</p>
<h4 id="问题-31"><a href="#问题-31" class="headerlink" title="问题"></a>问题</h4><p>删除节点</p>
<h4 id="思路-28"><a href="#思路-28" class="headerlink" title="思路"></a>思路</h4><p>用被删除结点之后的结点替换被删除结点</p>
<h4 id="C-33"><a href="#C-33" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void deleteNode(ListNode* node) &#123;</span><br><span class="line">    *node = *node -&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="100-Same-Tree"><a href="#100-Same-Tree" class="headerlink" title="100. Same Tree"></a>100. Same Tree</h3><p>Given two binary trees, write a function to check if they are equal or not.</p>
<p>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.</p>
<h4 id="问题-32"><a href="#问题-32" class="headerlink" title="问题"></a>问题</h4><p>判断两棵树是否相等</p>
<h4 id="思路-29"><a href="#思路-29" class="headerlink" title="思路"></a>思路</h4><p>递归判断</p>
<h4 id="C-34"><a href="#C-34" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bool isSameTree(TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">    </span><br><span class="line">    if (p == NULL || q == NULL) &#123;</span><br><span class="line">        return p==q;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return (p-&gt;val == q-&gt;val &amp;&amp; isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="169-Majority-Element"><a href="#169-Majority-Element" class="headerlink" title="169. Majority Element"></a>169. Majority Element</h3><p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array</p>
<h4 id="问题-33"><a href="#问题-33" class="headerlink" title="问题"></a>问题</h4><p>求一个数组中，出现次数超过一半的字符</p>
<h4 id="思路-30"><a href="#思路-30" class="headerlink" title="思路"></a>思路</h4><p>排序后，出现次数超过一半的字符肯定在中间</p>
<h4 id="C-35"><a href="#C-35" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">int majorityElement(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    </span><br><span class="line">    unordered_map&lt;int, int&gt; cnt;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        cnt[nums[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i=0; i&lt;nums.size(); i++) &#123;</span><br><span class="line">        if(cnt[nums[i]] &gt; nums.size()/2)&#123;</span><br><span class="line">            return nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="别人的写法-1"><a href="#别人的写法-1" class="headerlink" title="别人的写法"></a>别人的写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int majorityElement(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    nth_element(nums.begin(), nums.begin() + nums.size() / 2, nums.end());</span><br><span class="line">    return nums[nums.size() / 2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="242-Valid-Anagram"><a href="#242-Valid-Anagram" class="headerlink" title="242. Valid Anagram"></a>242. Valid Anagram</h3><p>Given two strings s and t, write a function to determine if t is an anagram of s.</p>
<h4 id="For-example-3"><a href="#For-example-3" class="headerlink" title="For example,"></a>For example,</h4><p>s = “anagram”, t = “nagaram”, return true.<br>s = “rat”, t = “car”, return false.</p>
<h4 id="Note-14"><a href="#Note-14" class="headerlink" title="Note:"></a>Note:</h4><p>You may assume the string contains only lowercase alphabets.</p>
<h4 id="Follow-up-2"><a href="#Follow-up-2" class="headerlink" title="Follow up:"></a>Follow up:</h4><p>What if the inputs contain unicode characters? How would you adapt your solution to such case?</p>
<h4 id="问题-34"><a href="#问题-34" class="headerlink" title="问题"></a>问题</h4><p>两个数组，问他们是否重新组合后是否为同一个单词</p>
<h4 id="思路-31"><a href="#思路-31" class="headerlink" title="思路"></a>思路</h4><p>对第二个数组中的字母一一计数，随后再对第一个数组中的字母一一扣除，如果为负，则false</p>
<h4 id="C-36"><a href="#C-36" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">bool isAnagram(string s, string t) &#123;</span><br><span class="line">    vector&lt;int&gt; count(26,0);</span><br><span class="line">    </span><br><span class="line">       if (s.size() != t.size()) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i=0; i&lt;s.size(); i++) &#123;</span><br><span class="line">        ++count[s[i]-&apos;a&apos;];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int j=0; j&lt;t.size(); j++) &#123;</span><br><span class="line">        if (--count[t[j]-&apos;a&apos;]&lt;0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return true;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="504-Base-7"><a href="#504-Base-7" class="headerlink" title="504. Base 7"></a>504. Base 7</h3><p>Given an integer, return its base 7 string representation.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: 100</span><br><span class="line">Output: &quot;202&quot;</span><br><span class="line">Example 2:</span><br><span class="line">Input: -7</span><br><span class="line">Output: &quot;-10&quot;</span><br><span class="line">Note: The input will be in range of [-1e7, 1e7].</span><br></pre></td></tr></table></figure>
<h4 id="问题-35"><a href="#问题-35" class="headerlink" title="问题"></a>问题</h4><p>给一个数，转化为7进制数</p>
<h4 id="思路-32"><a href="#思路-32" class="headerlink" title="思路"></a>思路</h4><p>递除取余</p>
<h4 id="C-37"><a href="#C-37" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">string convertToBase7(int num) &#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int n = num;</span><br><span class="line">    string res = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    num = abs(num);</span><br><span class="line">    do &#123;</span><br><span class="line">        res.insert(i,to_string(num%7));</span><br><span class="line">        num = num/7;</span><br><span class="line">    &#125; while (num != 0);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    return (n &gt;=0?&quot;&quot;:&quot;-&quot;) + res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="409-Longest-Palindrome"><a href="#409-Longest-Palindrome" class="headerlink" title="409. Longest Palindrome"></a>409. Longest Palindrome</h3><p>Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.</p>
<p>This is case sensitive, for example “Aa” is not considered a palindrome here.</p>
<h4 id="Note-15"><a href="#Note-15" class="headerlink" title="Note:"></a>Note:</h4><p>Assume the length of given string will not exceed 1,010.</p>
<h4 id="Example-11"><a href="#Example-11" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;abccccdd&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">One longest palindrome that can be built is &quot;dccaccd&quot;, whose length is 7.</span><br></pre></td></tr></table></figure>
<h4 id="问题-36"><a href="#问题-36" class="headerlink" title="问题"></a>问题</h4><p>求能组成的最长回文子串的长度</p>
<h4 id="思路-33"><a href="#思路-33" class="headerlink" title="思路"></a>思路</h4><p>统计所有偶数长度的字符并相加，统计所有奇数长度的字符并减一相加，只保留一个奇数不减一</p>
<h4 id="C-38"><a href="#C-38" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int longestPalindrome(string s) &#123;</span><br><span class="line">    vector&lt;int&gt; m(256,0);</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    for (auto i : s) &#123;</span><br><span class="line">        m[i-&apos;\0&apos;]++;</span><br><span class="line">    &#125;</span><br><span class="line">    for (auto j : m) &#123;</span><br><span class="line">        cnt += j % 2 ? (cnt % 2 ? j-1 : j) :  j;</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="217-Contains-Duplicate"><a href="#217-Contains-Duplicate" class="headerlink" title="217. Contains Duplicate"></a>217. Contains Duplicate</h3><p>Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p>
<h4 id="问题-37"><a href="#问题-37" class="headerlink" title="问题"></a>问题</h4><p>给一个数字数组，如果有重复的则返回true</p>
<h4 id="思路-34"><a href="#思路-34" class="headerlink" title="思路"></a>思路</h4><p>统计，遇到超过1的返回</p>
<h4 id="C-39"><a href="#C-39" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    unordered_map&lt;int, int&gt; map;</span><br><span class="line">    </span><br><span class="line">    if (nums.size()==0) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i: nums) &#123;</span><br><span class="line">        if(++map[i]&gt;1)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-Roman-to-Integer"><a href="#13-Roman-to-Integer" class="headerlink" title="13. Roman to Integer"></a>13. Roman to Integer</h3><p>Given a roman numeral, convert it to an integer.</p>
<p>Input is guaranteed to be within the range from 1 to 3999.</p>
<h4 id="问题-38"><a href="#问题-38" class="headerlink" title="问题"></a>问题</h4><p>转化罗马数字</p>
<h4 id="思路-35"><a href="#思路-35" class="headerlink" title="思路"></a>思路</h4><p>做一个字典，分小紧随大，大紧随小 两种罗马字符减加情况</p>
<h4 id="C-40"><a href="#C-40" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">    int romanToInt(string s)</span><br><span class="line">&#123;</span><br><span class="line">    unordered_map&lt;char, int&gt; map&#123;&#123;&apos;I&apos;, 1&#125;,</span><br><span class="line">                                 &#123;&apos;V&apos;, 5&#125;,</span><br><span class="line">                                 &#123;&apos;X&apos;, 10&#125;,</span><br><span class="line">                                 &#123;&apos;L&apos;, 50&#125;,</span><br><span class="line">                                 &#123;&apos;C&apos;, 100&#125;,</span><br><span class="line">                                 &#123;&apos;D&apos;, 500&#125;,</span><br><span class="line">                                 &#123;&apos;M&apos;, 1000&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    int res = 0;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; s.size(); i++) &#123;</span><br><span class="line">        if (map[s[i]]&lt;map[s[i+1]]) &#123;</span><br><span class="line">            res -= map[s[i]];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            res += map[s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="401-Binary-Watch"><a href="#401-Binary-Watch" class="headerlink" title="401. Binary Watch"></a>401. Binary Watch</h3><p>A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59).</p>
<p>Each LED represents a zero or one, with the least significant bit on the right.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/8/8b/Binary_clock_samui_moon.jpg" alt="image"><br>For example, the above binary watch reads “3:25”.</p>
<p>Given a non-negative integer n which represents the number of LEDs that are currently on, return all possible times the watch could represent.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 1</span><br><span class="line">Return: [&quot;1:00&quot;, &quot;2:00&quot;, &quot;4:00&quot;, &quot;8:00&quot;, &quot;0:01&quot;, &quot;0:02&quot;, &quot;0:04&quot;, &quot;0:08&quot;, &quot;0:16&quot;, &quot;0:32&quot;]</span><br><span class="line">Note:</span><br><span class="line">The order of output does not matter.</span><br><span class="line">The hour must not contain a leading zero, for example &quot;01:00&quot; is not valid, it should be &quot;1:00&quot;.</span><br><span class="line">The minute must be consist of two digits and may contain a leading zero, for example &quot;10:2&quot; is not valid, it should be &quot;10:02&quot;.</span><br></pre></td></tr></table></figure>
<h4 id="问题-39"><a href="#问题-39" class="headerlink" title="问题"></a>问题</h4><p>二进制手表，当亮点个数为n时，给出所有时间组合</p>
<h4 id="思路-36"><a href="#思路-36" class="headerlink" title="思路"></a>思路</h4><p>二进制表示各时间，符合count则添加进返回vector</p>
<h4 id="C-41"><a href="#C-41" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; readBinaryWatch(int num) &#123;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    for(int h = 0; h &lt; 12;h++)</span><br><span class="line">        for(int m = 0; m &lt; 60;m++)&#123;</span><br><span class="line">            if (bitset&lt;10&gt;(h&lt;&lt;6|m).count() == num) &#123;</span><br><span class="line">                res.emplace_back(to_string(h) + (m&lt;10?&quot;:0&quot;:&quot;:&quot;)  + to_string(m));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="收获-23"><a href="#收获-23" class="headerlink" title="收获"></a>收获</h4><p>bitset<10></10></p>
<p>emplace_back 比 push_back 更高效</p>
<h3 id="206-Reverse-Linked-List"><a href="#206-Reverse-Linked-List" class="headerlink" title="206. Reverse Linked List"></a>206. Reverse Linked List</h3><h4 id="问题-40"><a href="#问题-40" class="headerlink" title="问题"></a>问题</h4><p>翻转链表</p>
<h4 id="思路-37"><a href="#思路-37" class="headerlink" title="思路"></a>思路</h4><p>设立一个pre指针，一个next指针，进行翻转</p>
<h4 id="C-42"><a href="#C-42" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    ListNode *a = NULL;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    while(head)&#123;</span><br><span class="line">        ListNode *tmp = head-&gt;next;</span><br><span class="line">        head-&gt;next = a;</span><br><span class="line">        a=head;</span><br><span class="line">        head=tmp;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###</p>
<h4 id="问题-41"><a href="#问题-41" class="headerlink" title="问题"></a>问题</h4><h4 id="思路-38"><a href="#思路-38" class="headerlink" title="思路"></a>思路</h4><h4 id="C-43"><a href="#C-43" class="headerlink" title="C++"></a>C++</h4><h4 id="收获-24"><a href="#收获-24" class="headerlink" title="收获"></a>收获</h4>
  </section>

</article>

<section class="read-more">
           
    
               
            <div class="read-more-item">
                <span class="read-more-item-dim">Newer Post</span>
                <h2 class="post-list__post-title post-title"><a href="/2018/07/31/LeetCodePageTwo/" title="LeetCodePageTwo">LeetCodePageTwo</a></h2>
                <p class="excerpt">
                
                350. Intersection of Two Arrays IIGiven two arrays, write a function to compute their intersection.
Example:1Given nums1 = [1, 2, 2, 1], nums2 = [2, 2
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2018-07-31T03:45:16.184Z" class="post-list__meta--date date">2018-07-31</time> &#8226; <span class="post-list__meta--tags tags">于 </span><a class="btn-border-small" href="/2018/07/31/LeetCodePageTwo/">继续阅读</a></div>
                           
            </div>
        
        
               
            <div class="read-more-item">
                <span class="read-more-item-dim">Older Post</span>
                <h2 class="post-list__post-title post-title"><a href="/2018/07/23/HTML学习/" title=""></a></h2>
                <p class="excerpt">
                
                定义超文本标记语言  (英语：Hypertext Markup Language，简称：HTML )  是一种用来结构化 Web 网页及其内容的标记语言。
结构以1&amp;lt;p&amp;gt;My cat is very grumpy&amp;lt;/p&amp;gt;
这个元素的主要部分有：
开始标签（The openin
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2018-07-23T02:16:00.101Z" class="post-list__meta--date date">2018-07-23</time> &#8226; <span class="post-list__meta--tags tags">于 </span><a class="btn-border-small" href="/2018/07/23/HTML学习/">继续阅读</a></div>
                       
            </div>
        
     
   
   
  
</section>

  

            <footer class="footer">
    <span class="footer__copyright">
        &copy; 2018 Lio - 本站点采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
       
    </span>
    <span class="footer__copyright">
             - 基于 <a href="http://hexo.io">Hexo</a> 搭建，使用 <a href="https://github.com/monniya/hexo-theme-new-vno ">new-vno</a> 主题，由<a href="https://monniya.com ">@Monniya</a> 修改自 <a href="https://github.com/lenbo-ma/hexo-theme-vno" target="_blank">Vno</a>, 原创出自<a href="http://github.com/onevcat/vno" target="_blank">onevcat</a>
         </span>
       
    
    
</footer>


        </div>
    </div>

     
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-78918255-1', 'auto');
	ga('send', 'pageview');
</script>

    
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?9cdad07c755fa23f6aced510c6760e87";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>



    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    
</body>
</html>
