<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lio&#39;s dream</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/zhujiaxiang/zhujiaxiang.github.io/"/>
  <updated>2018-07-31T03:45:16.184Z</updated>
  <id>https://github.com/zhujiaxiang/zhujiaxiang.github.io/</id>
  
  <author>
    <name>Lio</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCodePageTwo</title>
    <link href="https://github.com/zhujiaxiang/zhujiaxiang.github.io/2018/07/31/LeetCodePageTwo/"/>
    <id>https://github.com/zhujiaxiang/zhujiaxiang.github.io/2018/07/31/LeetCodePageTwo/</id>
    <published>2018-07-31T03:45:16.184Z</published>
    <updated>2018-07-31T03:45:16.184Z</updated>
    
    <content type="html"><![CDATA[<h3 id="350-Intersection-of-Two-Arrays-II"><a href="#350-Intersection-of-Two-Arrays-II" class="headerlink" title="350. Intersection of Two Arrays II"></a>350. Intersection of Two Arrays II</h3><p>Given two arrays, write a function to compute their intersection.</p><h4 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].</span><br></pre></td></tr></table></figure><h4 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h4><p>Each element in the result should appear as many times as it shows in both arrays.<br>The result can be in any order.</p><h4 id="Follow-up"><a href="#Follow-up" class="headerlink" title="Follow up:"></a>Follow up:</h4><p>What if the given array is already sorted? How would you optimize your algorithm?</p><p>What if nums1’s size is small compared to nums2’s size? Which algorithm is better?</p><p>What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>求出两个数组中全部重复的元素</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>使用unordered_map 进行统计++，随后再比较–</p><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">    </span><br><span class="line">    unordered_map&lt;int, int&gt; map;</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    for (int i=0; i&lt;nums1.size(); i++) &#123;</span><br><span class="line">        ++map[nums1[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int j = 0; j &lt; nums2.size(); j++) &#123;</span><br><span class="line">        if (--map[nums2[j]] &gt;= 0) &#123;</span><br><span class="line">            res.push_back(nums2[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="268-Missing-Number"><a href="#268-Missing-Number" class="headerlink" title="268. Missing Number"></a>268. Missing Number</h3><p>Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array.</p><h4 id="For-example"><a href="#For-example" class="headerlink" title="For example,"></a>For example,</h4><p>Given nums = [0, 1, 3] return 2.</p><h4 id="Note-1"><a href="#Note-1" class="headerlink" title="Note:"></a>Note:</h4><p>Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?</p><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><p>给一个顺序数组，找出遗失的数字</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>通过^找出遗失的数字，多出的数字一定等于数组长度</p><h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    int missingNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    </span><br><span class="line">    int result = (int)nums.size();</span><br><span class="line">    int i = 0;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    for(auto num:nums)</span><br><span class="line">    &#123;</span><br><span class="line">        result ^= num;</span><br><span class="line">        result ^= i;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="447-Number-of-Boomerangs"><a href="#447-Number-of-Boomerangs" class="headerlink" title="447. Number of Boomerangs"></a>447. Number of Boomerangs</h3><p>Given n points in the plane that are all pairwise distinct, a “boomerang” is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters).</p><p>Find the number of boomerangs. You may assume that n will be at most 500 and coordinates of points are all in the range [-10000, 10000] (inclusive).</p><h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example:"></a>Example:</h4><h4 id="Input"><a href="#Input" class="headerlink" title="Input:"></a>Input:</h4><p>[[0,0],[1,0],[2,0]]</p><h4 id="Output"><a href="#Output" class="headerlink" title="Output:"></a>Output:</h4><p>2</p><h4 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation:"></a>Explanation:</h4><p>The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]]</p><h4 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h4><p>给出一系列坐标，通过这些坐标问你能找出几组回旋镖数组？回旋镖数组的意思是中点到两点距离相同。</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>使用欧氏距离计算两点距离（不开方）</p><p>使用unordered_map存储 距离：相同距离的边数，</p><p>再使用排列组合将边数的组合数全部加起来</p><h4 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    int numberOfBoomerangs(vector&lt;pair&lt;int, int&gt;&gt;&amp; points) &#123;</span><br><span class="line">    </span><br><span class="line">    int res = 0;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; points.size(); i++) &#123;</span><br><span class="line">        </span><br><span class="line">        unordered_map&lt;long, int&gt; cnt;</span><br><span class="line">        </span><br><span class="line">        for (int j = 0; j &lt; points.size(); j++) &#123;</span><br><span class="line">            if(i == j) continue;</span><br><span class="line">            int dx = points[i].first - points[j].first;</span><br><span class="line">            int dy = points[i].second - points[j].second;</span><br><span class="line">            </span><br><span class="line">            int key = dx * dx;</span><br><span class="line">            key += dy * dy;</span><br><span class="line">            </span><br><span class="line">            ++cnt[key];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for (auto i : cnt) &#123;</span><br><span class="line">            res += i.second * (i.second - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="541-Reverse-String-II"><a href="#541-Reverse-String-II" class="headerlink" title="541. Reverse String II"></a>541. Reverse String II</h3><p>Given a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.</p><h4 id="Example-2"><a href="#Example-2" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">Output: &quot;bacdfeg&quot;</span><br></pre></td></tr></table></figure><h4 id="Restrictions"><a href="#Restrictions" class="headerlink" title="Restrictions:"></a>Restrictions:</h4><p>The string consists of lower English letters only.<br>Length of the given string and k will in the range [1, 10000]</p><h4 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h4><p>给一个数组s，每隔k位翻转字符</p><h4 id="C-3"><a href="#C-3" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">string reverseStr(string s, int k) &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    for(int i=0;i&lt;s.size(); i += 2*k)&#123;</span><br><span class="line">        reverse(s.begin()+i,min(s.begin()+i+k,s.end()) );</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return s;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h4><p>min(s.begin()+i+k,s.end())</p><h3 id="551-Student-Attendance-Record-I"><a href="#551-Student-Attendance-Record-I" class="headerlink" title="551. Student Attendance Record I"></a>551. Student Attendance Record I</h3><p>You are given a string representing an attendance record for a student. The record only contains the following three characters:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&apos;A&apos; : Absent.</span><br><span class="line">&apos;L&apos; : Late.</span><br><span class="line">&apos;P&apos; : Present.</span><br><span class="line">A student could be rewarded if his attendance record doesn&apos;t contain more than one &apos;A&apos; (absent) or more than two continuous &apos;L&apos; (late).</span><br><span class="line"></span><br><span class="line">You need to return whether the student could be rewarded according to his attendance record.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line">Input: &quot;PPALLP&quot;</span><br><span class="line">Output: True</span><br><span class="line">Example 2:</span><br><span class="line">Input: &quot;PPALLL&quot;</span><br><span class="line">Output: False</span><br></pre></td></tr></table></figure><h4 id="问题-4"><a href="#问题-4" class="headerlink" title="问题"></a>问题</h4><p>给一组数组，超过1个A或者连续2个L则输出false</p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>使用map进行统计，遇到L则检查前两位是否是L</p><h4 id="C-4"><a href="#C-4" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">bool checkRecord(string s) &#123;</span><br><span class="line">    </span><br><span class="line">    unordered_map&lt;char, int&gt; map;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; s.size(); i++) &#123;</span><br><span class="line">        if (i&gt;1&amp;&amp;s[i]==&apos;L&apos;) &#123;</span><br><span class="line">            if (s[i-1] == &apos;L&apos;&amp;&amp;s[i-2] == &apos;L&apos;) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (s[i] == &apos;A&apos; &amp;&amp; ++map[s[i]]&gt;1) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="别人写法"><a href="#别人写法" class="headerlink" title="别人写法"></a>别人写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool checkRecord(string s) &#123;</span><br><span class="line">    return !regex_search(s, regex(&quot;A.*A|LLL&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获-1"><a href="#收获-1" class="headerlink" title="收获"></a>收获</h4><p>regex_search(s, regex(“A.*A|LLL”)) 正则表达式   </p><h3 id="543-Diameter-of-Binary-Tree"><a href="#543-Diameter-of-Binary-Tree" class="headerlink" title="543. Diameter of Binary Tree"></a>543. Diameter of Binary Tree</h3><p>Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.</p><h4 id="Example-3"><a href="#Example-3" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Given a binary tree </span><br><span class="line">          1</span><br><span class="line">         / \</span><br><span class="line">        2   3</span><br><span class="line">       / \     </span><br><span class="line">      4   5    </span><br><span class="line">Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].</span><br></pre></td></tr></table></figure><h4 id="Note-The-length-of-path-between-two-nodes-is-represented-by-the-number-of-edges-between-them"><a href="#Note-The-length-of-path-between-two-nodes-is-represented-by-the-number-of-edges-between-them" class="headerlink" title="Note: The length of path between two nodes is represented by the number of edges between them."></a>Note: The length of path between two nodes is represented by the number of edges between them.</h4><h4 id="问题-5"><a href="#问题-5" class="headerlink" title="问题"></a>问题</h4><p>找出二叉树中任意两点的最长距离</p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>使用DFS遍历左右子树，将两棵树的深度相加</p><h4 id="C-5"><a href="#C-5" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int maxDepth = 0;</span><br><span class="line"></span><br><span class="line">int dfs(TreeNode * root)</span><br><span class="line">&#123;</span><br><span class="line">    if (root ==NULL) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    int leftDepth = dfs(root-&gt;left);</span><br><span class="line">    int rightDepth = dfs(root-&gt;right);</span><br><span class="line">    </span><br><span class="line">    if (leftDepth + rightDepth &gt; maxDepth) &#123;</span><br><span class="line">        maxDepth = leftDepth + rightDepth;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return max(leftDepth + 1, rightDepth + 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int diameterOfBinaryTree(TreeNode* root) &#123;</span><br><span class="line">    dfs(root);</span><br><span class="line">    return maxDepth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="108-Convert-Sorted-Array-to-Binary-Search-Tree"><a href="#108-Convert-Sorted-Array-to-Binary-Search-Tree" class="headerlink" title="108. Convert Sorted Array to Binary Search Tree"></a>108. Convert Sorted Array to Binary Search Tree</h3><p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p><h4 id="问题-6"><a href="#问题-6" class="headerlink" title="问题"></a>问题</h4><p>将有序数组转化为二叉搜索树</p><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>去数组的中位数作为root，递归构建左右子树</p><h4 id="C-6"><a href="#C-6" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    </span><br><span class="line">    if (nums.size() == 0) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (nums.size() == 1) &#123;</span><br><span class="line">        return new TreeNode(nums[0]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int middle = (int)nums.size()/2;</span><br><span class="line">    </span><br><span class="line">    TreeNode *root = new TreeNode(nums[middle]);</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; leftInt(nums.begin(),nums.begin() + middle);</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; rightInt(nums.begin()+middle+1,nums.end());</span><br><span class="line">    </span><br><span class="line">    root-&gt;left = sortedArrayToBST(leftInt);</span><br><span class="line">    root-&gt;right = sortedArrayToBST(rightInt);</span><br><span class="line">    </span><br><span class="line">    return root;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="415-Add-Strings"><a href="#415-Add-Strings" class="headerlink" title="415. Add Strings"></a>415. Add Strings</h3><p>Given two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2.</p><h4 id="Note-2"><a href="#Note-2" class="headerlink" title="Note:"></a>Note:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The length of both num1 and num2 is &lt; 5100.</span><br><span class="line">Both num1 and num2 contains only digits 0-9.</span><br><span class="line">Both num1 and num2 does not contain any leading zero.</span><br><span class="line">You must not use any built-in BigInteger library or convert the inputs to integer directly.</span><br></pre></td></tr></table></figure><h4 id="问题-7"><a href="#问题-7" class="headerlink" title="问题"></a>问题</h4><p>给2个用string表示的数字，将其相加并输出，</p><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>进位（carry）累加到下一位计算,将最终结果逆序输出</p><h4 id="C-7"><a href="#C-7" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">string addStrings(string num1, string num2) &#123;</span><br><span class="line">    int carry =0;</span><br><span class="line">    int i = (int)num1.size() - 1;</span><br><span class="line">    int j = (int)num2.size() - 1;</span><br><span class="line">    </span><br><span class="line">    string res = &quot;&quot;;</span><br><span class="line">    </span><br><span class="line">    while(i&gt;=0||j&gt;=0||carry)</span><br><span class="line">    &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        if(i&gt;=0) sum += (num1[i] - &apos;0&apos;) ; i--;</span><br><span class="line">        if(j&gt;=0) sum += (num2[j] - &apos;0&apos;) ; j--;</span><br><span class="line">        </span><br><span class="line">        sum += carry;</span><br><span class="line">        </span><br><span class="line">        carry = sum / 10;</span><br><span class="line">        sum = sum % 10;</span><br><span class="line">        </span><br><span class="line">        res = res + to_string(sum);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    reverse(res.begin(), res.end());</span><br><span class="line">    </span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="405-Convert-a-Number-to-Hexadecimal"><a href="#405-Convert-a-Number-to-Hexadecimal" class="headerlink" title="405. Convert a Number to Hexadecimal"></a>405. Convert a Number to Hexadecimal</h3><p>Given an integer, write an algorithm to convert it to hexadecimal. For negative integer, two’s complement method is used.</p><h4 id="Note-3"><a href="#Note-3" class="headerlink" title="Note:"></a>Note:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">All letters in hexadecimal (a-f) must be in lowercase.</span><br><span class="line">The hexadecimal string must not contain extra leading 0s. If the number is zero, it is represented by a single zero character &apos;0&apos;; otherwise, the first character in the hexadecimal string will not be the zero character.</span><br><span class="line">The given number is guaranteed to fit within the range of a 32-bit signed integer.</span><br><span class="line">You must not use any method provided by the library which converts/formats the number to hex directly.</span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">26</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;1a&quot;</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">-1</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;ffffffff&quot;</span><br></pre></td></tr></table></figure><h4 id="问题-8"><a href="#问题-8" class="headerlink" title="问题"></a>问题</h4><p>将数转化为16进制数</p><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p>十进制&amp;15 输出的结果为对应16进制数的最后4位对应的十进制数</p><h4 id="C-8"><a href="#C-8" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">string toHex(int num) &#123;</span><br><span class="line">        int count = 0;</span><br><span class="line">        if(!num) return &quot;0&quot;;</span><br><span class="line">        string result;</span><br><span class="line">        while (num &amp;&amp; count &lt; 8)</span><br><span class="line">        &#123;</span><br><span class="line">            int temp = num &amp; 15;</span><br><span class="line">            if (temp&lt;10)    result.push_back(&apos;0&apos;+ temp);</span><br><span class="line">            else result.push_back(&apos;a&apos;+temp-10);</span><br><span class="line">            num = num &gt;&gt; 4;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(result.begin(),result.end());</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="收获-2"><a href="#收获-2" class="headerlink" title="收获"></a>收获</h4><p>num &amp; 15 转化16进制</p><h3 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121. Best Time to Buy and Sell Stock"></a>121. Best Time to Buy and Sell Stock</h3><p>Say you have an array for which the ith element is the price of a given stock on day i.</p><p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: [7, 1, 5, 3, 6, 4]</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><p>max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line">Input: [7, 6, 4, 3, 1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><p>In this case, no transaction is done, i.e. max profit = 0.</p><h4 id="问题-9"><a href="#问题-9" class="headerlink" title="问题"></a>问题</h4><p>给一组数组，a[i]代表第i天的股票价格，问只能进行一次买卖的话怎么样才能获得最大收益。</p><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p>每次取一个日期，遍历求出他能取得的最大收益，直到所有日期取完</p><h4 id="C-9"><a href="#C-9" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">    int maximum = 0;</span><br><span class="line">    for(int i = 0; i &lt; prices.size();i++)&#123;</span><br><span class="line">        int pre = prices[i];</span><br><span class="line">        </span><br><span class="line">        int j = i + 1;</span><br><span class="line">        while (j&lt;prices.size()&amp;&amp;prices[j]&gt;prices[i]) &#123;</span><br><span class="line">            maximum = max(maximum, prices[j]-pre);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return maximum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="202-Happy-Number"><a href="#202-Happy-Number" class="headerlink" title="202. Happy Number"></a>202. Happy Number</h3><p>Write an algorithm to determine if a number is “happy”.</p><p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p><p>Example: 19 is a happy number</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1^2 + 9^2 = 82</span><br><span class="line">8^2 + 2^2 = 68</span><br><span class="line">6^2 + 8^2 = 100</span><br><span class="line">1^2 + 0^2 + 0^2 = 1</span><br></pre></td></tr></table></figure><h4 id="问题-10"><a href="#问题-10" class="headerlink" title="问题"></a>问题</h4><p>找出happy number</p><h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><p>非happy number会出现循环解（听过insert进set的成功与否 来探查）</p><h4 id="C-10"><a href="#C-10" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bool isHappy(int n) &#123;</span><br><span class="line"></span><br><span class="line">    set&lt;int&gt; loopDetectSet;</span><br><span class="line">    int sum;</span><br><span class="line">    while (n!=1&amp;&amp;loopDetectSet.insert(n).second) &#123;</span><br><span class="line">         sum = 0;</span><br><span class="line">        while (n&gt;0) &#123;</span><br><span class="line">            sum = sum + (n%10) * (n%10);</span><br><span class="line">            n=n/10;</span><br><span class="line">        &#125;</span><br><span class="line">        n = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return n == 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获-3"><a href="#收获-3" class="headerlink" title="收获"></a>收获</h4><p>从数理角度考虑，数学归纳法？</p><h3 id="326-Power-of-Three"><a href="#326-Power-of-Three" class="headerlink" title="326. Power of Three"></a>326. Power of Three</h3><p>Given an integer, write a function to determine if it is a power of three.</p><p>Follow up:<br>Could you do it without using any loop / recursion?</p><h4 id="问题-11"><a href="#问题-11" class="headerlink" title="问题"></a>问题</h4><p>求一个数是否是三的倍数</p><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><p>log10（n）/log10（3）是否为整数</p><h4 id="C-11"><a href="#C-11" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool isPowerOfThree(int n) &#123;</span><br><span class="line">    return  fmod(log10(n)/log10(3), 1)  == 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="231-Power-of-Two"><a href="#231-Power-of-Two" class="headerlink" title="231. Power of Two"></a>231. Power of Two</h3><p>同上</p><h3 id="83-Remove-Duplicates-from-Sorted-List"><a href="#83-Remove-Duplicates-from-Sorted-List" class="headerlink" title="83. Remove Duplicates from Sorted List"></a>83. Remove Duplicates from Sorted List</h3><p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">For example,</span><br><span class="line">Given 1-&gt;1-&gt;2, return 1-&gt;2.</span><br><span class="line">Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3.</span><br></pre></td></tr></table></figure><h4 id="问题-12"><a href="#问题-12" class="headerlink" title="问题"></a>问题</h4><p>删除重复的结点</p><h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><h4 id="C-12"><a href="#C-12" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ListNode* deleteDuplicates(ListNode* head) &#123;</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    </span><br><span class="line">    while(cur!=NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        while (cur-&gt;next&amp;&amp;(cur-&gt;val == cur-&gt;next-&gt;val)) &#123;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return head;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="35-Search-Insert-Position"><a href="#35-Search-Insert-Position" class="headerlink" title="35. Search Insert Position"></a>35. Search Insert Position</h3><p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p><p>You may assume no duplicates in the array.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Here are few examples.</span><br><span class="line">[1,3,5,6], 5 → 2</span><br><span class="line">[1,3,5,6], 2 → 1</span><br><span class="line">[1,3,5,6], 7 → 4</span><br><span class="line">[1,3,5,6], 0 → 0</span><br></pre></td></tr></table></figure><h4 id="问题-13"><a href="#问题-13" class="headerlink" title="问题"></a>问题</h4><p>插入数字，返回位置</p><h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4><p>常规解法不提，提一提二分查找</p><h4 id="C-13"><a href="#C-13" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">    int low = 0;</span><br><span class="line">    int high = (int)nums.size() -1;</span><br><span class="line">    </span><br><span class="line">    while(low&lt;=high)&#123;</span><br><span class="line">        int mid = low + (low + high)/2;</span><br><span class="line">        if (target &lt; nums[mid]) &#123;</span><br><span class="line">            high = mid-1 ;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            low = mid +1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return low;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="437-Path-Sum-III"><a href="#437-Path-Sum-III" class="headerlink" title="437. Path Sum III"></a>437. Path Sum III</h3><p>You are given a binary tree in which each node contains an integer value.</p><p>Find the number of paths that sum to a given value.</p><p>The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).</p><p>The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</span><br><span class="line"></span><br><span class="line">      10</span><br><span class="line">     /  \</span><br><span class="line">    5   -3</span><br><span class="line">   / \    \</span><br><span class="line">  3   2   11</span><br><span class="line"> / \   \</span><br><span class="line">3  -2   1</span><br><span class="line"></span><br><span class="line">Return 3. The paths that sum to 8 are:</span><br><span class="line"></span><br><span class="line">1.  5 -&gt; 3</span><br><span class="line">2.  5 -&gt; 2 -&gt; 1</span><br><span class="line">3. -3 -&gt; 11</span><br></pre></td></tr></table></figure><h4 id="问题-14"><a href="#问题-14" class="headerlink" title="问题"></a>问题</h4><p>树种结点组合成指定数字的组合数，只能由父到子</p><h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h4><p>两次递归</p><h4 id="C-14"><a href="#C-14" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">    int pathSum(TreeNode* root, int sum) &#123;</span><br><span class="line">    </span><br><span class="line">    if(root == NULL) return 0;</span><br><span class="line">    return sumUp(root, 0, sum) + pathSum(root-&gt;left, sum) + pathSum(root-&gt;right, sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sumUp(TreeNode *root,int pre,int sum)</span><br><span class="line">&#123;</span><br><span class="line">    if(root == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int current = pre + root-&gt;val;</span><br><span class="line">    return (current == sum) + sumUp(root-&gt;left, current, sum) + sumUp(root-&gt;right, current, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="70-Climbing-Stairs"><a href="#70-Climbing-Stairs" class="headerlink" title="70. Climbing Stairs"></a>70. Climbing Stairs</h3><p>You are climbing a stair case. It takes n steps to reach to the top.</p><p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p><p>Note: Given n will be a positive integer.</p><h4 id="问题-15"><a href="#问题-15" class="headerlink" title="问题"></a>问题</h4><p>爬楼梯，一次只能爬1或者2，求有多少种爬法</p><h4 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h4><p>斐波那契数列</p><h4 id="C-15"><a href="#C-15" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   int climbStairs(int n) &#123;</span><br><span class="line">    int a= 0,b=1;</span><br><span class="line">    while (n--) &#123;</span><br><span class="line">        b = b+a;</span><br><span class="line">        a = b-a;</span><br><span class="line">    &#125;</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获-4"><a href="#收获-4" class="headerlink" title="收获"></a>收获</h4><p>###</p><h4 id="问题-16"><a href="#问题-16" class="headerlink" title="问题"></a>问题</h4><h4 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h4><h4 id="C-16"><a href="#C-16" class="headerlink" title="C++"></a>C++</h4><h4 id="收获-5"><a href="#收获-5" class="headerlink" title="收获"></a>收获</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;350-Intersection-of-Two-Arrays-II&quot;&gt;&lt;a href=&quot;#350-Intersection-of-Two-Arrays-II&quot; class=&quot;headerlink&quot; title=&quot;350. Intersection of Two A
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCodePageOne</title>
    <link href="https://github.com/zhujiaxiang/zhujiaxiang.github.io/2018/07/31/LeetCodePageOne/"/>
    <id>https://github.com/zhujiaxiang/zhujiaxiang.github.io/2018/07/31/LeetCodePageOne/</id>
    <published>2018-07-31T03:44:12.411Z</published>
    <updated>2018-07-31T03:44:54.223Z</updated>
    
    <content type="html"><![CDATA[<h3 id="461-Hamming-Distance"><a href="#461-Hamming-Distance" class="headerlink" title="461. Hamming Distance"></a>461. Hamming Distance</h3><p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different.</p><p>Given two integers x and y, calculate the Hamming distance.</p><h3 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h3><p>0 ≤ x, y &lt; 231.</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: x = 1, y = 4</span><br><span class="line"></span><br><span class="line">Output: 2</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">1   (0 0 0 1)</span><br><span class="line">4   (0 1 0 0)</span><br><span class="line">       ↑   ↑</span><br></pre></td></tr></table></figure><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>求两个数的二进制表示中，不同位数的个数。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>将两个数进行异或</li><li>统计异或后的数字中1的个数<h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int hammingDistance(int x, int y) &#123;</span><br><span class="line">        int dist = 0; int n = x^y;  //异或</span><br><span class="line">        while(n)</span><br><span class="line">        &#123;</span><br><span class="line">            ++dist;</span><br><span class="line">            n = n&amp;(n-1);</span><br><span class="line">        &#125;</span><br><span class="line">        return dist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="476-Number-Complement"><a href="#476-Number-Complement" class="headerlink" title="476. Number Complement"></a>476. Number Complement</h3><p>Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.</p><p>The above arrows point to positions where the corresponding bits are different.</p><h4 id="Note-1"><a href="#Note-1" class="headerlink" title="Note:"></a>Note:</h4><p>The given integer is guaranteed to fit within the range of a 32-bit signed integer.<br>You could assume no leading zero bit in the integer’s binary representation.</p><h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2</span><br></pre></td></tr></table></figure><h4 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 1</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.</span><br></pre></td></tr></table></figure><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>取一个正整数的二进制表达的反</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>制作一个mask 将正整数的二进制位数对应的位数 置为0；</li><li>将正整数取反 与 ~mask(00000000111)作与运算</li></ol><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findComplement(int num) &#123;</span><br><span class="line">      unsigned mask = ~0;             //制作mask</span><br><span class="line">        while (num &amp; mask) mask &lt;&lt;= 1;//根据正整数的二进制位数 将mask对应的位数置为0；</span><br><span class="line">        return ~mask &amp; ~num;          //将正整数取反，与mask作与运算</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="190-Reverse-Bits"><a href="#190-Reverse-Bits" class="headerlink" title="190. Reverse Bits"></a>190. Reverse Bits</h3><p>Reverse bits of a given 32 bits unsigned integer.</p><h4 id="For-example"><a href="#For-example" class="headerlink" title="For example"></a>For example</h4><p>given<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input 43261596 (represented in binary as 00000010100101000001111010011100)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">, return 964176192 (represented in binary as 00111001011110000010100101000000).</span><br></pre></td></tr></table></figure><h4 id="Follow-up"><a href="#Follow-up" class="headerlink" title="Follow up:"></a>Follow up:</h4><p>If this function is called many times, how would you optimize it?</p><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><p>反转比特</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>每次取最后一位加入result</li><li>再将imput右移抛出已加入的数字</li></ol><h3 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> uint32_t reverseBits(uint32_t input)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t result = 0;</span><br><span class="line">    const uint32_t BITS_OF_BYTES = 8 ;</span><br><span class="line">    for (int i=0; i&lt;sizeof(input)*BITS_OF_BYTES; i++) &#123;</span><br><span class="line">        result = (result &lt;&lt; 1 )|(input &amp; 1);            //result左移空出位置，将input最后一位加入</span><br><span class="line">        input = input &gt;&gt; 1;                            //input右移</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="500-Keyboard-Row"><a href="#500-Keyboard-Row" class="headerlink" title="500. Keyboard Row"></a>500. Keyboard Row</h3><p>Given a List of words, return the words that can be typed using letters of alphabet on only one row’s of American keyboard like the image below.<br><img src="https://leetcode.com/static/images/problemset/keyboard.png" alt="image"></p><h4 id="Example-1-1"><a href="#Example-1-1" class="headerlink" title="Example 1:"></a>Example 1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;Hello&quot;, &quot;Alaska&quot;, &quot;Dad&quot;, &quot;Peace&quot;]</span><br><span class="line">Output: [&quot;Alaska&quot;, &quot;Dad&quot;]</span><br></pre></td></tr></table></figure><h4 id="Note-2"><a href="#Note-2" class="headerlink" title="Note:"></a>Note:</h4><p>You may use one character in the keyboard more than once.</p><p>You may assume the input string will only contain letters of alphabet.</p><h4 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h4><p>给你一列表的单词，返回那些只包含美式键盘一行的单词</p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>查每个单词的第一个字母，将其设为某行，随后遍历每个字母，看是否都在那一行</p><h4 id="C-3"><a href="#C-3" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; findWords(std::vector&lt;std::string&gt; &amp;words)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    std::unordered_set&lt;char&gt; set1 = &#123;&apos;q&apos;, &apos;w&apos;, &apos;e&apos;, &apos;r&apos;, &apos;t&apos;, &apos;y&apos;, &apos;u&apos;, &apos;i&apos;, &apos;o&apos;, &apos;p&apos;&#125;;</span><br><span class="line">    std::unordered_set&lt;char&gt; set2 = &#123;&apos;a&apos;, &apos;s&apos;, &apos;d&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;&#125;;</span><br><span class="line">    std::unordered_set&lt;char&gt; set3 = &#123;&apos;z&apos;, &apos;x&apos;, &apos;c&apos;, &apos;v&apos;, &apos;b&apos;, &apos;n&apos;, &apos;m&apos;&#125;;</span><br><span class="line">    std::vector&lt;std::unordered_set&lt;char&gt;&gt; sets = &#123;set1, set2, set3&#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::string&gt; result;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; words.size(); i++) &#123;</span><br><span class="line">        int index = 0, flag = 0;</span><br><span class="line">        if (set1.find(tolower(words[i][0])) != set1.end()) &#123;</span><br><span class="line">            index = 0;</span><br><span class="line">        &#125; else if (set2.find(tolower(words[i][0])) != set2.end()) &#123;</span><br><span class="line">            index = 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            index = 2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::unordered_set&lt;char&gt; tempset = sets[index];</span><br><span class="line"></span><br><span class="line">        for (char a : words[i]) &#123;</span><br><span class="line">            if (tempset.find(tolower(a)) == tempset.end()) &#123;</span><br><span class="line">                flag = 1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (flag == 0) &#123;</span><br><span class="line">            result.push_back(words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h4><p>==using namespace std; or using std::xxxxx；==</p><h3 id="412-Fizz-Buzz"><a href="#412-Fizz-Buzz" class="headerlink" title="412. Fizz Buzz"></a>412. Fizz Buzz</h3><p>Write a program that outputs the string representation of numbers from 1 to n.</p><p>But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.</p><h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">n = 15,</span><br><span class="line"></span><br><span class="line">Return:</span><br><span class="line">[</span><br><span class="line">    &quot;1&quot;,</span><br><span class="line">    &quot;2&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;4&quot;,</span><br><span class="line">    &quot;Buzz&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;7&quot;,</span><br><span class="line">    &quot;8&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;Buzz&quot;,</span><br><span class="line">    &quot;11&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;13&quot;,</span><br><span class="line">    &quot;14&quot;,</span><br><span class="line">    &quot;FizzBuzz&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="问题-4"><a href="#问题-4" class="headerlink" title="问题"></a>问题</h4><p>给一个N 从1到n中的数 放入数组，如果是三的倍数输出Fizz，五的倍数输出Buzz，三五的倍数输出FizzBuzz</p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>分支判断</p><h4 id="C-4"><a href="#C-4" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; fizzBuzz(int n)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;string&gt; a;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        if (i%15==0) &#123;</span><br><span class="line">            a.push_back(&quot;FizzBuzz&quot;);</span><br><span class="line">        &#125;else if (i%5==0)&#123;</span><br><span class="line">            a.push_back(&quot;Buzz&quot;);</span><br><span class="line">        &#125;else if (i%3==0)&#123;</span><br><span class="line">            a.push_back(&quot;Fizz&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            a.push_back(to_string(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获-1"><a href="#收获-1" class="headerlink" title="收获"></a>收获</h4><p>==to_string()== int=&gt;string</p><h4 id="别人写法"><a href="#别人写法" class="headerlink" title="别人写法"></a>别人写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; fizzBuzz(int n) &#123;</span><br><span class="line">        vector&lt;string&gt; ret_vec(n);</span><br><span class="line">        for(int i=1; i&lt;=n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i%3 == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                ret_vec[i-1] += string(&quot;Fizz&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if(i%5 == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                ret_vec[i-1] += string(&quot;Buzz&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if(ret_vec[i-1] == &quot;&quot;)</span><br><span class="line">            &#123;</span><br><span class="line">                ret_vec[i-1] += to_string(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret_vec;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="344-Reverse-String"><a href="#344-Reverse-String" class="headerlink" title="344. Reverse String"></a>344. Reverse String</h3><p>Write a function that takes a string as input and returns the string reversed.</p><h4 id="Example-2"><a href="#Example-2" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given s = &quot;hello&quot;, return &quot;olleh&quot;.</span><br></pre></td></tr></table></figure><h3 id="C-5"><a href="#C-5" class="headerlink" title="C++"></a>C++</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">string reverseString(string s) &#123;</span><br><span class="line">    </span><br><span class="line">    if(s==&quot;&quot;)&#123;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125; ;</span><br><span class="line">    string result = &quot;&quot;;</span><br><span class="line">    int length = (int)s.length();</span><br><span class="line">    </span><br><span class="line">    if(length != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = length; i&gt;0; i--) &#123;</span><br><span class="line">            char temp = s[i-1];</span><br><span class="line">            result+=temp;       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="别人写法-1"><a href="#别人写法-1" class="headerlink" title="别人写法"></a>别人写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string reverseString(string s) &#123;</span><br><span class="line">       int i = 0, j = s.size() - 1;</span><br><span class="line">       while(i &lt; j)&#123;</span><br><span class="line">           swap(s[i++], s[j--]); </span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       return s;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="收获-2"><a href="#收获-2" class="headerlink" title="收获"></a>收获</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swap函数</span><br></pre></td></tr></table></figure><h3 id="496-Next-Greater-Element-I"><a href="#496-Next-Greater-Element-I" class="headerlink" title="496. Next Greater Element I"></a>496. Next Greater Element I</h3><p>You are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1’s elements in the corresponding places of nums2.</p><p>The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number.</p><h4 id="Example-1-2"><a href="#Example-1-2" class="headerlink" title="Example 1:"></a>Example 1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [4,1,2], nums2 = [1,3,4,2].</span><br><span class="line">Output: [-1,3,-1]</span><br><span class="line">Explanation:</span><br><span class="line">    For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.</span><br><span class="line">    For number 1 in the first array, the next greater number for it in the second array is 3.</span><br><span class="line">    For number 2 in the first array, there is no next greater number for it in the second array, so output -1.</span><br></pre></td></tr></table></figure><h4 id="Example-2-1"><a href="#Example-2-1" class="headerlink" title="Example 2:"></a>Example 2:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [2,4], nums2 = [1,2,3,4].</span><br><span class="line">Output: [3,-1]</span><br><span class="line">Explanation:</span><br><span class="line">    For number 2 in the first array, the next greater number for it in the second array is 3.</span><br><span class="line">    For number 4 in the first array, there is no next greater number for it in the second array, so output -1.</span><br></pre></td></tr></table></figure><h4 id="Note-3"><a href="#Note-3" class="headerlink" title="Note:"></a>Note:</h4><p>All elements in nums1 and nums2 are unique.</p><p>The length of both nums1 and nums2 would not exceed 1000.</p><h3 id="C-6"><a href="#C-6" class="headerlink" title="C++"></a>C++</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; findNums, vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int n = findNums.size();</span><br><span class="line">    int m = nums.size();</span><br><span class="line">    vector&lt;int&gt; result(n);</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;m;j++)&#123;</span><br><span class="line">            if (findNums[i] == nums[j]) &#123;</span><br><span class="line"></span><br><span class="line">                for (int k=j; k&lt;m; k++) &#123;</span><br><span class="line">                    if (nums[k]&gt;findNums[i]) &#123;</span><br><span class="line">                        result[i]=nums[k];</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                if (!result[i]) &#123;</span><br><span class="line">                    result[i]=-1;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                break;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                result[i] = -1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="别人写法-2"><a href="#别人写法-2" class="headerlink" title="别人写法"></a>别人写法</h3><p>通过建立一个键值对，预先保存nums中每个数的nextGreaterElement，随后对其进行查找。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line"> vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; findNums, vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">unordered_map&lt;int, int&gt; mark;</span><br><span class="line">deque&lt;int&gt; next;</span><br><span class="line">for (auto i : nums)&#123;</span><br><span class="line">while (!next.empty() &amp;&amp; i &gt; next.back())&#123;</span><br><span class="line">mark[next.back()] = i;</span><br><span class="line">next.pop_back();</span><br><span class="line">&#125;</span><br><span class="line">next.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;int &gt;res;</span><br><span class="line">for (auto i : findNums)&#123;</span><br><span class="line">if (mark.find(i) != mark.end())&#123;</span><br><span class="line">res.push_back(mark[i]);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">res.push_back(-1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="463-Island-Perimeter"><a href="#463-Island-Perimeter" class="headerlink" title="463. Island Perimeter"></a>463. Island Perimeter</h3><p>You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn’t have “lakes” (water inside that isn’t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island.</p><h4 id="Example-3"><a href="#Example-3" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[[0,1,0,0],</span><br><span class="line"> [1,1,1,0],</span><br><span class="line"> [0,1,0,0],</span><br><span class="line"> [1,1,0,0]]</span><br><span class="line"></span><br><span class="line">Answer: 16</span><br><span class="line">Explanation: The perimeter is the 16 yellow stripes in the image below:</span><br></pre></td></tr></table></figure><p><img src="https://leetcode.com/static/images/problemset/island.png" alt="image"></p><h4 id="问题-5"><a href="#问题-5" class="headerlink" title="问题"></a>问题</h4><p>0是海1是岛，求岛的边界</p><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>从非边缘行，列开始遍历，遍历到1，count++，检查其左上两个是否也为一，若为1记录为一个repeat，</p><h4 id="C-7"><a href="#C-7" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    int repeat = 0;</span><br><span class="line">    for (int i=0; i&lt;grid.size(); i++) &#123;</span><br><span class="line">        for (int j=0; j&lt;grid[i].size(); j++) &#123;</span><br><span class="line">            if (grid[i][j] == 1) &#123;</span><br><span class="line">                count ++;</span><br><span class="line">                if (j!=0 &amp;&amp; grid[i][j-1] == 1) &#123;</span><br><span class="line">                    repeat ++;</span><br><span class="line">                &#125;</span><br><span class="line">                if (i!=0 &amp;&amp; grid[i-1][j] == 1) &#123;</span><br><span class="line">                    repeat ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return count * 4 -repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获-3"><a href="#收获-3" class="headerlink" title="收获"></a>收获</h4><p>遍历二维vector的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int i=0; i&lt;grid.size(); i++) </span><br><span class="line">&#123;</span><br><span class="line">        for (int j=0; j&lt;grid[i].size(); j++) </span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="292-Nim-Game"><a href="#292-Nim-Game" class="headerlink" title="292. Nim Game"></a>292. Nim Game</h3><p>You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.</p><p>Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.</p><p>For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.</p><h4 id="Hint"><a href="#Hint" class="headerlink" title="Hint:"></a>Hint:</h4><p>If there are 5 stones in the heap, could you figure out a way to remove the stones such that you will always be the winner?</p><h4 id="问题-6"><a href="#问题-6" class="headerlink" title="问题"></a>问题</h4><p>取石头 一个人能取1，2，3块石头，如果你是先手，判断是否能赢</p><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>是4的倍数必输</p><h4 id="C-8"><a href="#C-8" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool canWinNim(int n) &#123;</span><br><span class="line">        return (n &amp;0B11) != 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="收获-4"><a href="#收获-4" class="headerlink" title="收获"></a>收获</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(n % 4) != 0 </span><br><span class="line">(n &amp;0B11) != 0;</span><br></pre></td></tr></table></figure><h3 id="485-Max-Consecutive-Ones"><a href="#485-Max-Consecutive-Ones" class="headerlink" title="485. Max Consecutive Ones"></a>485. Max Consecutive Ones</h3><p>Given a binary array, find the maximum number of consecutive 1s in this array.</p><h4 id="Example-1-3"><a href="#Example-1-3" class="headerlink" title="Example 1:"></a>Example 1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,0,1,1,1]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The first two digits or the last three digits are consecutive 1s.</span><br><span class="line">    The maximum number of consecutive 1s is 3.</span><br></pre></td></tr></table></figure><h4 id="Note-4"><a href="#Note-4" class="headerlink" title="Note:"></a>Note:</h4><p>The input array will only contain 0 and 1.</p><p>The length of input array is a positive integer and will not exceed 10,000</p><h4 id="问题-7"><a href="#问题-7" class="headerlink" title="问题"></a>问题</h4><p>求最长的连续1的数量</p><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p>做一个mark数组标记0的位置，再进行处理</p><h4 id="C-9"><a href="#C-9" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int findMaxConsecutiveOnes(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">   vector&lt;int&gt; mark;</span><br><span class="line">   int count = 0;</span><br><span class="line">   mark.push_back(-1);</span><br><span class="line">   for(int i=0;i&lt;nums.size();i++)&#123;</span><br><span class="line">       if (nums[i] == 0) &#123;</span><br><span class="line">           mark.push_back(i);</span><br><span class="line">           count ++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   if(count == 0)&#123;</span><br><span class="line">       return (int)nums.size();</span><br><span class="line">   &#125;</span><br><span class="line">   mark.push_back(nums.size());</span><br><span class="line">   int max = 0;</span><br><span class="line">   for (int j=1; j&lt;mark.size(); j++) &#123;</span><br><span class="line">       if (mark[j]-mark[j-1] -1 &gt;max) &#123;</span><br><span class="line">           max = mark[j]-mark[j-1]-1;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return max;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h4 id="别人写法-3"><a href="#别人写法-3" class="headerlink" title="别人写法"></a>别人写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int findMaxConsecutiveOnes(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">int max=0,cur=0;</span><br><span class="line">for(int i=0;i&lt;nums.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">if(nums[i]&amp;1)</span><br><span class="line">&#123;</span><br><span class="line">max=max&gt;++cur?max:cur;</span><br><span class="line">&#125;</span><br><span class="line">else cur=0;</span><br><span class="line">&#125;</span><br><span class="line">return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获-5"><a href="#收获-5" class="headerlink" title="收获"></a>收获</h4><p>别想太复杂</p><h3 id="136-Single-Number"><a href="#136-Single-Number" class="headerlink" title="136. Single Number"></a>136. Single Number</h3><p>Given an array of integers, every element appears twice except for one. Find that single one.</p><h4 id="Note-5"><a href="#Note-5" class="headerlink" title="Note:"></a>Note:</h4><p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p><h4 id="问题-8"><a href="#问题-8" class="headerlink" title="问题"></a>问题</h4><p>求一个数组中的单个数字，要求线性时间复杂度，无额外空间</p><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p>异或为0</p><h4 id="C-10"><a href="#C-10" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">            for(int i=1;i&lt;nums.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[0]=nums[0]^nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return nums[0];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="收获-6"><a href="#收获-6" class="headerlink" title="收获"></a>收获</h4><p>多关注位运算，异或，与，非，反</p><h3 id="448-Find-All-Numbers-Disappeared-in-an-Array"><a href="#448-Find-All-Numbers-Disappeared-in-an-Array" class="headerlink" title="448. Find All Numbers Disappeared in an Array"></a>448. Find All Numbers Disappeared in an Array</h3><p>Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.</p><p>Find all the elements of [1, n] inclusive that do not appear in this array.</p><p>Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.</p><h4 id="Example-4"><a href="#Example-4" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[5,6]</span><br></pre></td></tr></table></figure><h4 id="问题-9"><a href="#问题-9" class="headerlink" title="问题"></a>问题</h4><p>寻找数组中消失的数字</p><h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><p>把数字放到该放的地方，然后找出消失的数字</p><h4 id="C-11"><a href="#C-11" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int len = (int)nums.size();</span><br><span class="line">    for (int i=0; i&lt;len; i++) &#123;</span><br><span class="line">        int m = abs(nums[i])-1;</span><br><span class="line">        nums[m]= nums[m]&gt;0?-nums[m]:nums[m];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    for (int i=0; i&lt;len; i++) &#123;</span><br><span class="line">        if(nums[i] &gt; 0) res.push_back(i+1);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="520-Detect-Capital"><a href="#520-Detect-Capital" class="headerlink" title="520. Detect Capital"></a>520. Detect Capital</h3><p>Given a word, you need to judge whether the usage of capitals in it is right or not.</p><p>We define the usage of capitals in a word to be right when one of the following cases holds:</p><p>All letters in this word are capitals, like “USA”.<br>All letters in this word are not capitals, like “leetcode”.<br>Only the first letter in this word is capital if it has more than one letter, like “Google”.<br>Otherwise, we define that this word doesn’t use capitals in a right way.</p><h4 id="Example-1-4"><a href="#Example-1-4" class="headerlink" title="Example 1:"></a>Example 1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;USA&quot;</span><br><span class="line">Output: True</span><br></pre></td></tr></table></figure><h4 id="Example-2-2"><a href="#Example-2-2" class="headerlink" title="Example 2:"></a>Example 2:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;FlaG&quot;</span><br><span class="line">Output: False</span><br></pre></td></tr></table></figure><h4 id="Note-6"><a href="#Note-6" class="headerlink" title="Note:"></a>Note:</h4><p>The input will be a non-empty word consisting of uppercase and lowercase latin letters.</p><h4 id="问题-10"><a href="#问题-10" class="headerlink" title="问题"></a>问题</h4><p>看string是否符合标准大写规则</p><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><p>分支判断</p><h4 id="C-12"><a href="#C-12" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">bool detectCapitalUse(string word) &#123;</span><br><span class="line">    char c = word[0];</span><br><span class="line">    if (!isupper(c)) &#123;</span><br><span class="line">        for (auto a:word) &#123;</span><br><span class="line">            if (isupper(a)) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        if (isupper(word[1])) &#123;</span><br><span class="line">            for (auto a:word) &#123;</span><br><span class="line">                if (islower(a)) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            for(int i = 2;i&lt;word.length();i++)&#123;</span><br><span class="line">                if (isupper(word[i])) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="别人写法-4"><a href="#别人写法-4" class="headerlink" title="别人写法"></a>别人写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public boolean detectCapitalUse(String word) &#123;</span><br><span class="line">       int cnt = 0;</span><br><span class="line">       for(char c: word.toCharArray()) if(&apos;Z&apos; - c &gt;= 0) cnt++;</span><br><span class="line">       return ((cnt==0 || cnt==word.length()) || (cnt==1 &amp;&amp; &apos;Z&apos; - word.charAt(0)&gt;=0));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="收获-7"><a href="#收获-7" class="headerlink" title="收获"></a>收获</h4><p>通过ASC码判断，大写字母的ASC码比小写字母小。</p><h3 id="104-Maximum-Depth-of-Binary-Tree"><a href="#104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104. Maximum Depth of Binary Tree"></a>104. Maximum Depth of Binary Tree</h3><h4 id="问题-11"><a href="#问题-11" class="headerlink" title="问题"></a>问题</h4><p>求树的最大深度</p><h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><p>深度优先||广度优先</p><h4 id="C-13"><a href="#C-13" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">深度优先</span><br><span class="line">int maxDepth(TreeNode* root) &#123;</span><br><span class="line">    return root == NULL ? 0 :max(maxDepth(root-&gt;left), maxDepth(root-&gt;right))+1;</span><br><span class="line">&#125;</span><br><span class="line">广度优先</span><br><span class="line">int maxDepth(TreeNode *root)</span><br><span class="line">&#123;</span><br><span class="line">    if(root == NULL)</span><br><span class="line">        return 0;</span><br><span class="line">    </span><br><span class="line">    int res = 0;</span><br><span class="line">    queue&lt;TreeNode *&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        ++ res;</span><br><span class="line">        for(int i = 0, n = q.size(); i &lt; n; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode *p = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            </span><br><span class="line">            if(p -&gt; left != NULL)</span><br><span class="line">                q.push(p -&gt; left);</span><br><span class="line">            if(p -&gt; right != NULL)</span><br><span class="line">                q.push(p -&gt; right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="389-Find-the-Difference"><a href="#389-Find-the-Difference" class="headerlink" title="389. Find the Difference"></a>389. Find the Difference</h3><h4 id="问题-12"><a href="#问题-12" class="headerlink" title="问题"></a>问题</h4><p>寻找两个字符串不同的字符</p><h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4><p>位运算 异或能找出单个不同的字符</p><h4 id="C-14"><a href="#C-14" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">char findTheDifference(string s, string t) &#123;</span><br><span class="line"></span><br><span class="line">    char res = &apos;\0&apos;;</span><br><span class="line">    for (char a:s) &#123;</span><br><span class="line">        res = res^a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (char b:t) &#123;</span><br><span class="line">        res = res^b;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res;</span><br><span class="line">    </span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获-8"><a href="#收获-8" class="headerlink" title="收获"></a>收获</h4><p>异或找不同</p><h3 id="371-Sum-of-Two-Integers"><a href="#371-Sum-of-Two-Integers" class="headerlink" title="371. Sum of Two Integers"></a>371. Sum of Two Integers</h3><p>Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.</p><h4 id="Example-5"><a href="#Example-5" class="headerlink" title="Example:"></a>Example:</h4><p>Given a = 1 and b = 2, return 3.</p><h4 id="问题-13"><a href="#问题-13" class="headerlink" title="问题"></a>问题</h4><p>在不使用+ -的情况下 实现加法</p><h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h4><p>通过异或来实现0+1或1+0，通过与并左移实现进位</p><h4 id="C-15"><a href="#C-15" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int getSum(int a, int b) &#123;</span><br><span class="line">    int sum = a;</span><br><span class="line">    while (b!=0) &#123;</span><br><span class="line">        sum = a^b;</span><br><span class="line">        b = (a&amp;b)&lt;&lt;1;</span><br><span class="line">        a = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获-9"><a href="#收获-9" class="headerlink" title="收获"></a>收获</h4><p>可以通过异或来实现0+1或1+0，通过与+左移实现进位</p><h3 id="226-Invert-Binary-Tree"><a href="#226-Invert-Binary-Tree" class="headerlink" title="226. Invert Binary Tree"></a>226. Invert Binary Tree</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Invert a binary tree.</span><br><span class="line"></span><br><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  2     7</span><br><span class="line"> / \   / \</span><br><span class="line">1   3 6   9</span><br><span class="line">to</span><br><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  7     2</span><br><span class="line"> / \   / \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure><h4 id="问题-14"><a href="#问题-14" class="headerlink" title="问题"></a>问题</h4><p>翻转二叉树</p><h4 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h4><p>递归，非递归（广度优先）</p><h4 id="C-16"><a href="#C-16" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">递归</span><br><span class="line">TreeNode* invertTree(TreeNode* root) &#123;</span><br><span class="line">              if(root == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (root) &#123;</span><br><span class="line">        TreeNode *temp = root-&gt;left;</span><br><span class="line">        root-&gt;left = root-&gt;right;</span><br><span class="line">        root-&gt;right = temp;</span><br><span class="line">        </span><br><span class="line">        if(root-&gt;left !=NULL)&#123;</span><br><span class="line">            invertTree(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        if (root-&gt;right !=NULL) &#123;</span><br><span class="line">            invertTree(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return root;</span><br><span class="line">    &#125;</span><br><span class="line">非递归</span><br><span class="line">TreeNode *invertTree(TreeNode *root)</span><br><span class="line">&#123;</span><br><span class="line">    stack&lt;TreeNode *&gt; stack;</span><br><span class="line">    stack.push(root);</span><br><span class="line">    while (!stack.empty()) &#123;</span><br><span class="line">        TreeNode *p = stack.top();</span><br><span class="line">        stack.pop();</span><br><span class="line">        if (p) &#123;</span><br><span class="line">            stack.push(root-&gt;left);</span><br><span class="line">            stack.push(root-&gt;right);</span><br><span class="line">            swap(root-&gt;left, root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获-10"><a href="#收获-10" class="headerlink" title="收获"></a>收获</h4><p>swap函数</p><h3 id="258-Add-Digits"><a href="#258-Add-Digits" class="headerlink" title="258. Add Digits"></a>258. Add Digits</h3><p>Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.</p><h4 id="For-example-1"><a href="#For-example-1" class="headerlink" title="For example:"></a>For example:</h4><p>Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.</p><h4 id="Follow-up-1"><a href="#Follow-up-1" class="headerlink" title="Follow up:"></a>Follow up:</h4><p>Could you do it without any loop/recursion in O(1) runtime?</p><h4 id="问题-15"><a href="#问题-15" class="headerlink" title="问题"></a>问题</h4><p>38-》3+8=11》1+1》2  一个数，各位数相加，直至只剩一位数</p><h4 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h4><p><a href="https://www.zhihu.com/question/30972581" target="_blank" rel="noopener">数根</a></p><h4 id="C-17"><a href="#C-17" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int addDigits(int num) &#123;</span><br><span class="line">    return 1+(num-1)%9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获-11"><a href="#收获-11" class="headerlink" title="收获"></a>收获</h4><p>12345 % 9 = (1 + 2 + 3 + 4 +5 ) % 9 </p><h3 id="492-Construct-the-Rectangle"><a href="#492-Construct-the-Rectangle" class="headerlink" title="492. Construct the Rectangle"></a>492. Construct the Rectangle</h3><p>For a web developer, it is very important to know how to design a web page’s size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. The area of the rectangular web page you designed must equal to the given target area.</span><br><span class="line"></span><br><span class="line">2. The width W should not be larger than the length L, which means L &gt;= W.</span><br><span class="line"></span><br><span class="line">3. The difference between length L and width W should be as small as possible.</span><br><span class="line">You need to output the length L and the width W of the web page you designed in sequence.</span><br></pre></td></tr></table></figure><h4 id="Example-6"><a href="#Example-6" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: [2, 2]</span><br><span class="line">Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. </span><br><span class="line">But according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.</span><br></pre></td></tr></table></figure><h4 id="Note-7"><a href="#Note-7" class="headerlink" title="Note:"></a>Note:</h4><p>The given area won’t exceed 10,000,000 and is a positive integer<br>The web page’s width and length you designed must be positive integers</p><h4 id="问题-16"><a href="#问题-16" class="headerlink" title="问题"></a>问题</h4><p>给定一个正方形面积，求出符合要求的一组长款</p><h4 id="收获-12"><a href="#收获-12" class="headerlink" title="收获"></a>收获</h4><p>时间复杂度，的优化</p><h4 id="C-18"><a href="#C-18" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">写法1：99ms</span><br><span class="line">vector&lt;int&gt; constructRectangle(int area) &#123;</span><br><span class="line">    </span><br><span class="line">    int l = sqrt(area);</span><br><span class="line">    for(int i = l;i&lt;=area;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (area%i==0) &#123;</span><br><span class="line">            l=i;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int w = area/l;</span><br><span class="line">    </span><br><span class="line">    if(w&gt;l)&#123;</span><br><span class="line">        swap(w,l);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; result = &#123;l,w&#125;;</span><br><span class="line">    </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">更新写法2：3ms</span><br><span class="line">vector&lt;int&gt; constructRectangle(int area) &#123;</span><br><span class="line">    </span><br><span class="line">    int w ;</span><br><span class="line">    for(int i = 1;i*i&lt;=area;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (area%i==0) &#123;</span><br><span class="line">            w=i;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; result = &#123;area/w,w&#125;;</span><br><span class="line">    </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获-13"><a href="#收获-13" class="headerlink" title="收获"></a>收获</h4><p>不用系统函数，想办法替代</p><h3 id="283-Move-Zeroes"><a href="#283-Move-Zeroes" class="headerlink" title="283. Move Zeroes"></a>283. Move Zeroes</h3><p>Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p><p>For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].</p><h4 id="Note-8"><a href="#Note-8" class="headerlink" title="Note:"></a>Note:</h4><p>You must do this in-place without making a copy of the array.<br>Minimize the total number of operations.</p><h4 id="问题-17"><a href="#问题-17" class="headerlink" title="问题"></a>问题</h4><p>将数组中的0移动到数组末尾</p><h4 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h4><p>遇到非0就覆盖原数组，最后再将0添上</p><h4 id="C-19"><a href="#C-19" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int j = 0;</span><br><span class="line">    for (int i=0; i&lt;nums.size(); i++) &#123;</span><br><span class="line">        if (nums[i]!=0) &#123;</span><br><span class="line">            nums[j++]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (; j&lt;nums.size(); j++) &#123;</span><br><span class="line">        nums[j] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="506-Relative-Ranks"><a href="#506-Relative-Ranks" class="headerlink" title="506. Relative Ranks"></a>506. Relative Ranks</h3><p>Given scores of N athletes, find their relative ranks and the people with the top three highest scores, who will be awarded medals: “Gold Medal”, “Silver Medal” and “Bronze Medal”.</p><h4 id="Example-1-5"><a href="#Example-1-5" class="headerlink" title="Example 1:"></a>Example 1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [5, 4, 3, 2, 1]</span><br><span class="line">Output: [&quot;Gold Medal&quot;, &quot;Silver Medal&quot;, &quot;Bronze Medal&quot;, &quot;4&quot;, &quot;5&quot;]</span><br><span class="line">Explanation: The first three athletes got the top three highest scores, so they got &quot;Gold Medal&quot;, &quot;Silver Medal&quot; and &quot;Bronze Medal&quot;. </span><br><span class="line">For the left two athletes, you just need to output their relative ranks according to their scores.</span><br></pre></td></tr></table></figure><h4 id="Note-9"><a href="#Note-9" class="headerlink" title="Note:"></a>Note:</h4><p>N is a positive integer and won’t exceed 10,000.<br>All the scores of athletes are guaranteed to be unique.</p><h4 id="问题-18"><a href="#问题-18" class="headerlink" title="问题"></a>问题</h4><p>根据数组中的得，输出其对应的排名    </p><h4 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a>思路</h4><p>利用C++ map的递增特性，进行输出</p><h4 id="C-20"><a href="#C-20" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; findRelativeRanks(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line"></span><br><span class="line">    map&lt;int,int&gt; mp;</span><br><span class="line">    </span><br><span class="line">    for (int i=0; i&lt;nums.size(); i++) &#123;</span><br><span class="line">        mp[nums[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;string&gt; res(nums.size(),&quot;&quot;);</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    for (map&lt;int,int&gt;::reverse_iterator it = mp.rbegin(); it!=mp.rend(); it++,cnt++) &#123;</span><br><span class="line">        if (cnt== 0) &#123;</span><br><span class="line">            res[it-&gt;second] = &quot;Gold Medal&quot;;</span><br><span class="line">        &#125;else if (cnt==1)&#123;</span><br><span class="line">            res[it-&gt;second] = &quot;Silver Medal&quot;;</span><br><span class="line">        &#125;else if (cnt==2)&#123;</span><br><span class="line">            res[it-&gt;second] = &quot;Bronze Medal&quot;;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            res[it-&gt;second] = to_string(cnt+1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获-14"><a href="#收获-14" class="headerlink" title="收获"></a>收获</h4><p>C++ map是递增的，it—&gt;first是key it-&gt;second是value，倒序遍历迭代器的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(map&lt;int,int&gt;::reverse_iterator it=mp.rbegin();it!+mp.rend();it++)</span><br></pre></td></tr></table></figure><h3 id="530-Minimum-Absolute-Difference-in-BST"><a href="#530-Minimum-Absolute-Difference-in-BST" class="headerlink" title="530. Minimum Absolute Difference in BST"></a>530. Minimum Absolute Difference in BST</h3><p>Given a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.</p><h4 id="Example-7"><a href="#Example-7" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     3</span><br><span class="line">    /</span><br><span class="line">   2</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h4 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation:"></a>Explanation:</h4><p>The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).<br>Note: There are at least two nodes in this BST.</p><h4 id="问题-19"><a href="#问题-19" class="headerlink" title="问题"></a>问题</h4><p>求二叉搜索树中，求两个结点绝对值相差最小的值</p><h4 id="思路-18"><a href="#思路-18" class="headerlink" title="思路"></a>思路</h4><p>中序遍历出的二叉搜索树是有序递增的，在这个有序的队列中求最小值</p><h4 id="C-21"><a href="#C-21" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> public:void inorderTraverse(TreeNode* root, int&amp; val, int&amp; min_dif) &#123;</span><br><span class="line">    if (root-&gt;left != NULL) inorderTraverse(root-&gt;left, val, min_dif);</span><br><span class="line">    if (val &gt;= 0) min_dif = min(min_dif, root-&gt;val - val);</span><br><span class="line">    val = root-&gt;val;</span><br><span class="line">    if (root-&gt;right != NULL) inorderTraverse(root-&gt;right, val, min_dif);</span><br><span class="line">&#125;</span><br><span class="line">public:int getMinimumDifference(TreeNode* root) &#123;</span><br><span class="line">    auto min_dif = INT_MAX, val = -1;</span><br><span class="line">    inorderTraverse(root, val, min_dif);</span><br><span class="line">    return min_dif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获-15"><a href="#收获-15" class="headerlink" title="收获"></a>收获</h4><p>中序遍历二叉搜索树是有序的</p><h3 id="167-Two-Sum-II-Input-array-is-sorted"><a href="#167-Two-Sum-II-Input-array-is-sorted" class="headerlink" title="167. Two Sum II - Input array is sorted"></a>167. Two Sum II - Input array is sorted</h3><p>Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.</p><p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p><p>You may assume that each input would have exactly one solution and you may not use the same element twice.</p><h4 id="Input"><a href="#Input" class="headerlink" title="Input:"></a>Input:</h4><p>numbers={2, 7, 11, 15}, target=9</p><h4 id="Output"><a href="#Output" class="headerlink" title="Output:"></a>Output:</h4><p>index1=1, index2=2</p><h4 id="问题-20"><a href="#问题-20" class="headerlink" title="问题"></a>问题</h4><p>给一个数组，给一个目标，找出相加为目标数的两个数在数组中的位置</p><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>一左一右两个指针， while</p><h4 id="C-22"><a href="#C-22" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;</span><br><span class="line">    </span><br><span class="line">    int r = (int)numbers.size() - 1;</span><br><span class="line">    </span><br><span class="line">    int l = 0;</span><br><span class="line">    </span><br><span class="line">    while (l&lt;r) &#123;</span><br><span class="line">        if (numbers[l] + numbers[r] == target) &#123;</span><br><span class="line">          vector&lt;int&gt; res&#123;l+1,r+1&#125;;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;else if(numbers[l] + numbers[r] &gt; target)&#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;else if(numbers[l] + numbers[r] &lt; target)&#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; fail;</span><br><span class="line">    return fail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="521-Longest-Uncommon-Subsequence-I"><a href="#521-Longest-Uncommon-Subsequence-I" class="headerlink" title="521. Longest Uncommon Subsequence I"></a>521. Longest Uncommon Subsequence I</h3><p>Given a group of two strings, you need to find the longest uncommon subsequence of this group of two strings. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings.</p><p>A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.</p><p>The input will be two strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn’t exist, return -1.</p><h4 id="Example-1-6"><a href="#Example-1-6" class="headerlink" title="Example 1:"></a>Example 1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;aba&quot;, &quot;cdc&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The longest uncommon subsequence is &quot;aba&quot; (or &quot;cdc&quot;), </span><br><span class="line">because &quot;aba&quot; is a subsequence of &quot;aba&quot;, </span><br><span class="line">but not a subsequence of any other strings in the group of two strings.</span><br></pre></td></tr></table></figure><h4 id="Note-10"><a href="#Note-10" class="headerlink" title="Note:"></a>Note:</h4><p>Both strings’ lengths will not exceed 100.<br>Only letters from a ~ z will appear in input strings.</p><h4 id="问题-21"><a href="#问题-21" class="headerlink" title="问题"></a>问题</h4><p>两个字符串中最长的字符串是否是第二个字符串的子串，如果是则返回-1，否做返回其长度</p><h4 id="C-23"><a href="#C-23" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int findLUSlength(string a, string b) &#123;</span><br><span class="line">    </span><br><span class="line">    if (a.size() == b.size()) &#123;</span><br><span class="line">        if (a==b) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return (int)a.size();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return (int)max(a.size(), b.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="455-Assign-Cookies"><a href="#455-Assign-Cookies" class="headerlink" title="455. Assign Cookies"></a>455. Assign Cookies</h3><p>Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj &gt;= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.</p><h4 id="Note-11"><a href="#Note-11" class="headerlink" title="Note:"></a>Note:</h4><p>You may assume the greed factor is always positive.<br>You cannot assign more than one cookie to one child.</p><h4 id="Example-1-7"><a href="#Example-1-7" class="headerlink" title="Example 1:"></a>Example 1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3], [1,1]</span><br><span class="line"></span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. </span><br><span class="line">And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.</span><br><span class="line">You need to output 1.</span><br></pre></td></tr></table></figure><h4 id="Example-2-3"><a href="#Example-2-3" class="headerlink" title="Example 2:"></a>Example 2:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2], [1,2,3]</span><br><span class="line"></span><br><span class="line">Output: 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. </span><br><span class="line">You have 3 cookies and their sizes are big enough to gratify all of the children, </span><br><span class="line">You need to output 2.</span><br></pre></td></tr></table></figure><h4 id="问题-22"><a href="#问题-22" class="headerlink" title="问题"></a>问题</h4><p>给小孩分曲奇，两个数组<br>第一个是小孩的需求数组【1，2，3】，代表有3个小孩，分别要1，2，3大小的曲奇<br>第二个是自己拥有的曲奇数组【1，2】代表有2个曲奇，大小分别为1，2</p><h4 id="思路-19"><a href="#思路-19" class="headerlink" title="思路"></a>思路</h4><p>贪心算法，先对两个数组进行递增排序，随后开始比较，作一个关于饼干数组的循环，如果遇到合适的小孩，则分配给他，然后对下一个下小孩进行分析</p><h4 id="C-24"><a href="#C-24" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123;</span><br><span class="line">    sort(g.begin(),g.end());</span><br><span class="line">    sort(s.begin(), s.end());</span><br><span class="line">    </span><br><span class="line">    int i=0,j=0;</span><br><span class="line">    </span><br><span class="line">    for (; i &lt; g.size()&amp;&amp; j &lt; s.size(); j++) &#123;</span><br><span class="line">        if (g[i]&lt;=s[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="收获-16"><a href="#收获-16" class="headerlink" title="收获"></a>收获</h4><p>贪心算法，sort函数</p><h3 id="453-Minimum-Moves-to-Equal-Array-Elements"><a href="#453-Minimum-Moves-to-Equal-Array-Elements" class="headerlink" title="453. Minimum Moves to Equal Array Elements"></a>453. Minimum Moves to Equal Array Elements</h3><p>Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1.</p><h4 id="Example-8"><a href="#Example-8" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[1,2,3]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h4 id="Explanation-1"><a href="#Explanation-1" class="headerlink" title="Explanation:"></a>Explanation:</h4><p>Only three moves are needed (remember each move increments two elements):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3]  =&gt;  [2,3,3]  =&gt;  [3,4,3]  =&gt;  [4,4,4]</span><br></pre></td></tr></table></figure><h4 id="问题-23"><a href="#问题-23" class="headerlink" title="问题"></a>问题</h4><p>给一组n个数，每次只能进行n-1个数的+1操作，问将他们都变为相同的数字最少需要几步。</p><h4 id="思路-20"><a href="#思路-20" class="headerlink" title="思路"></a>思路</h4><p>（min+k）<em>n = sum+k</em>(n-1)<br>k = sum - min*n</p><h4 id="C-25"><a href="#C-25" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int minMoves(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    </span><br><span class="line">    if (nums.size()&lt;=1) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        int sum=0,minimum=INT_MAX;</span><br><span class="line">        for (int i=0; i&lt;nums.size(); i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            minimum = min(minimum,nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        int res = sum-(int)(minimum*nums.size());</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="别人写法-5"><a href="#别人写法-5" class="headerlink" title="别人写法"></a>别人写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int minMoves(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    return accumulate(begin(nums), end(nums), 0L) - nums.size() * *min_element(begin(nums), end(nums));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获-17"><a href="#收获-17" class="headerlink" title="收获"></a>收获</h4><p>列出等式，找规律 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;numeric&gt;</span><br><span class="line">int sum = accumulate(begin(nums), end(nums), 0);</span><br><span class="line">min_element(begin(nums), end(nums));</span><br></pre></td></tr></table></figure><h3 id="383-Ransom-Note"><a href="#383-Ransom-Note" class="headerlink" title="383. Ransom Note"></a>383. Ransom Note</h3><p>Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false.</p><p>Each letter in the magazine string can only be used once in your ransom note.</p><h4 id="Note-12"><a href="#Note-12" class="headerlink" title="Note:"></a>Note:</h4><p>You may assume that both strings contain only lowercase letters.</p><p>canConstruct(“a”, “b”) -&gt; false<br>canConstruct(“aa”, “ab”) -&gt; false<br>canConstruct(“aa”, “aab”) -&gt; true</p><h4 id="问题-24"><a href="#问题-24" class="headerlink" title="问题"></a>问题</h4><p>给两个数组，如果能用第二个数组中的元素构成第一个数组，则返回true</p><h4 id="思路-21"><a href="#思路-21" class="headerlink" title="思路"></a>思路</h4><p>对数组2的每一个字母进行计数+1，计数完后再对数组1对应进行计数-1，如果有数计数&lt;0，则返回false，否则则返回true</p><h4 id="C-26"><a href="#C-26" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bool canConstruct(string ransomNote, string magazine) &#123;</span><br><span class="line">    vector&lt;int&gt; vec(26,0);</span><br><span class="line">    </span><br><span class="line">    for (int i=0; i&lt;magazine.size(); i++) &#123;</span><br><span class="line">        ++vec[magazine[i]-&apos;a&apos;];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int j=0; j&lt;ransomNote.size(); j++) &#123;</span><br><span class="line">        if (--vec[ransomNote[j]-&apos;a&apos;]&lt;0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获-18"><a href="#收获-18" class="headerlink" title="收获"></a>收获</h4><p>一种比较的思路</p><h3 id="349-Intersection-of-Two-Arrays"><a href="#349-Intersection-of-Two-Arrays" class="headerlink" title="349. Intersection of Two Arrays"></a>349. Intersection of Two Arrays</h3><p>Given two arrays, write a function to compute their intersection.</p><h4 id="Example-9"><a href="#Example-9" class="headerlink" title="Example:"></a>Example:</h4><p>Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].</p><h4 id="Note-13"><a href="#Note-13" class="headerlink" title="Note:"></a>Note:</h4><p>Each element in the result must be unique.<br>The result can be in any order.<br>Subscribe to see which companies asked this question.</p><h4 id="问题-25"><a href="#问题-25" class="headerlink" title="问题"></a>问题</h4><p>给2个数组，找出共同的元素</p><h4 id="思路-22"><a href="#思路-22" class="headerlink" title="思路"></a>思路</h4><p>比较，去除重复元素 使用unique</p><h4 id="C-27"><a href="#C-27" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">    if(nums1.size()&lt;=0||nums2.size()&lt;=0)</span><br><span class="line">    &#123;</span><br><span class="line">        return vector&lt;int&gt;&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    sort(nums1.begin(),nums1.end());</span><br><span class="line">    sort(nums2.begin(),nums2.end());</span><br><span class="line">    int i=0,j=0;</span><br><span class="line">    for (; i&lt;nums1.size()&amp;&amp;j&lt;nums2.size(); j++) &#123;</span><br><span class="line">        if (nums1[i]==nums2[j]) &#123;</span><br><span class="line">            res.push_back(nums1[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;else if (nums1[i]&lt;nums2[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt;::iterator new_end;</span><br><span class="line">    new_end=unique(res.begin(),res.end());</span><br><span class="line">    res.erase(new_end, res.end());</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获-19"><a href="#收获-19" class="headerlink" title="收获"></a>收获</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">去除重复元素</span><br><span class="line"></span><br><span class="line">new_end=unique(res.begin(),res.end());</span><br><span class="line">res.erase(new_end, res.end());</span><br></pre></td></tr></table></figure><h3 id="404-Sum-of-Left-Leaves"><a href="#404-Sum-of-Left-Leaves" class="headerlink" title="404. Sum of Left Leaves"></a>404. Sum of Left Leaves</h3><p>Find the sum of all left leaves in a given binary tree.</p><h4 id="Example-10"><a href="#Example-10" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.</p><h4 id="问题-26"><a href="#问题-26" class="headerlink" title="问题"></a>问题</h4><p>统计一棵树的左叶子和</p><h4 id="思路-23"><a href="#思路-23" class="headerlink" title="思路"></a>思路</h4><p>递归</p><h4 id="C-28"><a href="#C-28" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int sumOfLeftLeaves(TreeNode* root) &#123;</span><br><span class="line">    </span><br><span class="line">    if(!root)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    if (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) &#123;</span><br><span class="line">        return root-&gt;left-&gt;val + sumOfLeftLeaves(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return sumOfLeftLeaves(root-&gt;left) + sumOfLeftLeaves(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获-20"><a href="#收获-20" class="headerlink" title="收获"></a>收获</h4><p>从最小的一部分观察，制定递归策略</p><h3 id="122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122. Best Time to Buy and Sell Stock II"></a>122. Best Time to Buy and Sell Stock II</h3><p>Say you have an array for which the ith element is the price of a given stock on day i.</p><p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p><h4 id="问题-27"><a href="#问题-27" class="headerlink" title="问题"></a>问题</h4><p>给一个数组，数组i代表天数，a[i-1]代表当天股票价值，问怎么样才能获取最大值？</p><h4 id="思路-24"><a href="#思路-24" class="headerlink" title="思路"></a>思路</h4><p>累加差值，如果遇到下跌的天数就跳过</p><h4 id="C-29"><a href="#C-29" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int maxProfit(vector&lt;int&gt; &amp;prices)</span><br><span class="line">&#123;</span><br><span class="line">    if (prices.size() == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int maximum = 0;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; prices.size()-1; i++) &#123;</span><br><span class="line">       </span><br><span class="line">        if (prices[i] &lt; prices[i+1]) &#123;</span><br><span class="line">            maximum = maximum + prices[i+1]-prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return maximum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="别人的写法"><a href="#别人的写法" class="headerlink" title="别人的写法"></a>别人的写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int maxProfit(vector&lt;int&gt; &amp;prices) &#123;</span><br><span class="line">    int ret = 0;</span><br><span class="line">    for (size_t p = 1; p &lt; prices.size(); ++p) </span><br><span class="line">      ret += max(prices[p] - prices[p - 1], 0);    </span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获-21"><a href="#收获-21" class="headerlink" title="收获"></a>收获</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (prices[i] &lt; prices[i+1]) </span><br><span class="line">&#123;</span><br><span class="line">     maximum = maximum + prices[i+1]-prices[i];</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"> ret += max(prices[p] - prices[p - 1], 0);</span><br></pre></td></tr></table></figure><h3 id="387-First-Unique-Character-in-a-String"><a href="#387-First-Unique-Character-in-a-String" class="headerlink" title="387. First Unique Character in a String"></a>387. First Unique Character in a String</h3><p>Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1.</p><h4 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;leetcode&quot;</span><br><span class="line">return 0.</span><br><span class="line"></span><br><span class="line">s = &quot;loveleetcode&quot;,</span><br><span class="line">return 2.</span><br></pre></td></tr></table></figure><h4 id="问题-28"><a href="#问题-28" class="headerlink" title="问题"></a>问题</h4><p>求string中第一个不重复的字符的下标</p><h4 id="思路-25"><a href="#思路-25" class="headerlink" title="思路"></a>思路</h4><p>使用map将string按字符一个个存入map，并count</p><h4 id="C-30"><a href="#C-30" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int firstUniqChar(string s) &#123;</span><br><span class="line">    unordered_map&lt;char, int&gt; map;</span><br><span class="line">    </span><br><span class="line">    for(auto c:s)</span><br><span class="line">    &#123;</span><br><span class="line">        map[c]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i&lt; s.size(); i++) &#123;</span><br><span class="line">        if(map[s[i]] - 1 ==0)</span><br><span class="line">        &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获-22"><a href="#收获-22" class="headerlink" title="收获"></a>收获</h4><p>多用键值对，通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i&lt; s.size(); i++) &#123;</span><br><span class="line">        if(map[s[i]] - 1 ==0)</span><br><span class="line">        &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>能实现按顺序查找第一个不重复的字符。</p><h3 id="122-Best-Time-to-Buy-and-Sell-Stock-II-1"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II-1" class="headerlink" title="122. Best Time to Buy and Sell Stock II"></a>122. Best Time to Buy and Sell Stock II</h3><p>Say you have an array for which the ith element is the price of a given stock on day i.</p><p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p><h4 id="问题-29"><a href="#问题-29" class="headerlink" title="问题"></a>问题</h4><p>给定一个数组 下标为天数，各个元素为当天股票价格，球可获利的最大值</p><h4 id="思路-26"><a href="#思路-26" class="headerlink" title="思路"></a>思路</h4><p>累加</p><h4 id="C-31"><a href="#C-31" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int maxProfit(vector&lt;int&gt; &amp;prices) &#123;</span><br><span class="line">    int ret = 0;</span><br><span class="line">    for (size_t p = 1; p &lt; prices.size(); ++p) </span><br><span class="line">      ret += max(prices[p] - prices[p - 1], 0);    </span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="171-Excel-Sheet-Column-Number"><a href="#171-Excel-Sheet-Column-Number" class="headerlink" title="171. Excel Sheet Column Number"></a>171. Excel Sheet Column Number</h3><p>Given a column title as appear in an Excel sheet, return its corresponding column number.</p><h4 id="For-example-2"><a href="#For-example-2" class="headerlink" title="For example:"></a>For example:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; 1</span><br><span class="line">B -&gt; 2</span><br><span class="line">C -&gt; 3</span><br><span class="line">...</span><br><span class="line">Z -&gt; 26</span><br><span class="line">AA -&gt; 27</span><br><span class="line">AB -&gt; 28</span><br></pre></td></tr></table></figure><h4 id="问题-30"><a href="#问题-30" class="headerlink" title="问题"></a>问题</h4><p>类似于Excel的列标题，求其代表的数字</p><h4 id="思路-27"><a href="#思路-27" class="headerlink" title="思路"></a>思路</h4><p>按位数分析累加</p><h4 id="C-32"><a href="#C-32" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int titleToNumber(string s) &#123;</span><br><span class="line">    </span><br><span class="line">    int res = 0;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; s.size(); res = res*26 + s[i] - &apos;A&apos; + 1 , i++ ) ;</span><br><span class="line">    </span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="237-Delete-Node-in-a-Linked-Lis"><a href="#237-Delete-Node-in-a-Linked-Lis" class="headerlink" title="237. Delete Node in a Linked Lis"></a>237. Delete Node in a Linked Lis</h3><p>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.</p><p>Supposed the linked list is 1 -&gt; 2 -&gt; 3 -&gt; 4 and you are given the third node with value 3, the linked list should become 1 -&gt; 2 -&gt; 4 after calling your function.</p><h4 id="问题-31"><a href="#问题-31" class="headerlink" title="问题"></a>问题</h4><p>删除节点</p><h4 id="思路-28"><a href="#思路-28" class="headerlink" title="思路"></a>思路</h4><p>用被删除结点之后的结点替换被删除结点</p><h4 id="C-33"><a href="#C-33" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void deleteNode(ListNode* node) &#123;</span><br><span class="line">    *node = *node -&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="100-Same-Tree"><a href="#100-Same-Tree" class="headerlink" title="100. Same Tree"></a>100. Same Tree</h3><p>Given two binary trees, write a function to check if they are equal or not.</p><p>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.</p><h4 id="问题-32"><a href="#问题-32" class="headerlink" title="问题"></a>问题</h4><p>判断两棵树是否相等</p><h4 id="思路-29"><a href="#思路-29" class="headerlink" title="思路"></a>思路</h4><p>递归判断</p><h4 id="C-34"><a href="#C-34" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bool isSameTree(TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">    </span><br><span class="line">    if (p == NULL || q == NULL) &#123;</span><br><span class="line">        return p==q;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return (p-&gt;val == q-&gt;val &amp;&amp; isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="169-Majority-Element"><a href="#169-Majority-Element" class="headerlink" title="169. Majority Element"></a>169. Majority Element</h3><p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p><p>You may assume that the array is non-empty and the majority element always exist in the array</p><h4 id="问题-33"><a href="#问题-33" class="headerlink" title="问题"></a>问题</h4><p>求一个数组中，出现次数超过一半的字符</p><h4 id="思路-30"><a href="#思路-30" class="headerlink" title="思路"></a>思路</h4><p>排序后，出现次数超过一半的字符肯定在中间</p><h4 id="C-35"><a href="#C-35" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">int majorityElement(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    </span><br><span class="line">    unordered_map&lt;int, int&gt; cnt;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        cnt[nums[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i=0; i&lt;nums.size(); i++) &#123;</span><br><span class="line">        if(cnt[nums[i]] &gt; nums.size()/2)&#123;</span><br><span class="line">            return nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="别人的写法-1"><a href="#别人的写法-1" class="headerlink" title="别人的写法"></a>别人的写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int majorityElement(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    nth_element(nums.begin(), nums.begin() + nums.size() / 2, nums.end());</span><br><span class="line">    return nums[nums.size() / 2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="242-Valid-Anagram"><a href="#242-Valid-Anagram" class="headerlink" title="242. Valid Anagram"></a>242. Valid Anagram</h3><p>Given two strings s and t, write a function to determine if t is an anagram of s.</p><h4 id="For-example-3"><a href="#For-example-3" class="headerlink" title="For example,"></a>For example,</h4><p>s = “anagram”, t = “nagaram”, return true.<br>s = “rat”, t = “car”, return false.</p><h4 id="Note-14"><a href="#Note-14" class="headerlink" title="Note:"></a>Note:</h4><p>You may assume the string contains only lowercase alphabets.</p><h4 id="Follow-up-2"><a href="#Follow-up-2" class="headerlink" title="Follow up:"></a>Follow up:</h4><p>What if the inputs contain unicode characters? How would you adapt your solution to such case?</p><h4 id="问题-34"><a href="#问题-34" class="headerlink" title="问题"></a>问题</h4><p>两个数组，问他们是否重新组合后是否为同一个单词</p><h4 id="思路-31"><a href="#思路-31" class="headerlink" title="思路"></a>思路</h4><p>对第二个数组中的字母一一计数，随后再对第一个数组中的字母一一扣除，如果为负，则false</p><h4 id="C-36"><a href="#C-36" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">bool isAnagram(string s, string t) &#123;</span><br><span class="line">    vector&lt;int&gt; count(26,0);</span><br><span class="line">    </span><br><span class="line">       if (s.size() != t.size()) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i=0; i&lt;s.size(); i++) &#123;</span><br><span class="line">        ++count[s[i]-&apos;a&apos;];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int j=0; j&lt;t.size(); j++) &#123;</span><br><span class="line">        if (--count[t[j]-&apos;a&apos;]&lt;0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return true;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="504-Base-7"><a href="#504-Base-7" class="headerlink" title="504. Base 7"></a>504. Base 7</h3><p>Given an integer, return its base 7 string representation.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: 100</span><br><span class="line">Output: &quot;202&quot;</span><br><span class="line">Example 2:</span><br><span class="line">Input: -7</span><br><span class="line">Output: &quot;-10&quot;</span><br><span class="line">Note: The input will be in range of [-1e7, 1e7].</span><br></pre></td></tr></table></figure><h4 id="问题-35"><a href="#问题-35" class="headerlink" title="问题"></a>问题</h4><p>给一个数，转化为7进制数</p><h4 id="思路-32"><a href="#思路-32" class="headerlink" title="思路"></a>思路</h4><p>递除取余</p><h4 id="C-37"><a href="#C-37" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">string convertToBase7(int num) &#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int n = num;</span><br><span class="line">    string res = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    num = abs(num);</span><br><span class="line">    do &#123;</span><br><span class="line">        res.insert(i,to_string(num%7));</span><br><span class="line">        num = num/7;</span><br><span class="line">    &#125; while (num != 0);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    return (n &gt;=0?&quot;&quot;:&quot;-&quot;) + res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="409-Longest-Palindrome"><a href="#409-Longest-Palindrome" class="headerlink" title="409. Longest Palindrome"></a>409. Longest Palindrome</h3><p>Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.</p><p>This is case sensitive, for example “Aa” is not considered a palindrome here.</p><h4 id="Note-15"><a href="#Note-15" class="headerlink" title="Note:"></a>Note:</h4><p>Assume the length of given string will not exceed 1,010.</p><h4 id="Example-11"><a href="#Example-11" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;abccccdd&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">One longest palindrome that can be built is &quot;dccaccd&quot;, whose length is 7.</span><br></pre></td></tr></table></figure><h4 id="问题-36"><a href="#问题-36" class="headerlink" title="问题"></a>问题</h4><p>求能组成的最长回文子串的长度</p><h4 id="思路-33"><a href="#思路-33" class="headerlink" title="思路"></a>思路</h4><p>统计所有偶数长度的字符并相加，统计所有奇数长度的字符并减一相加，只保留一个奇数不减一</p><h4 id="C-38"><a href="#C-38" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int longestPalindrome(string s) &#123;</span><br><span class="line">    vector&lt;int&gt; m(256,0);</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    for (auto i : s) &#123;</span><br><span class="line">        m[i-&apos;\0&apos;]++;</span><br><span class="line">    &#125;</span><br><span class="line">    for (auto j : m) &#123;</span><br><span class="line">        cnt += j % 2 ? (cnt % 2 ? j-1 : j) :  j;</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="217-Contains-Duplicate"><a href="#217-Contains-Duplicate" class="headerlink" title="217. Contains Duplicate"></a>217. Contains Duplicate</h3><p>Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p><h4 id="问题-37"><a href="#问题-37" class="headerlink" title="问题"></a>问题</h4><p>给一个数字数组，如果有重复的则返回true</p><h4 id="思路-34"><a href="#思路-34" class="headerlink" title="思路"></a>思路</h4><p>统计，遇到超过1的返回</p><h4 id="C-39"><a href="#C-39" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    unordered_map&lt;int, int&gt; map;</span><br><span class="line">    </span><br><span class="line">    if (nums.size()==0) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i: nums) &#123;</span><br><span class="line">        if(++map[i]&gt;1)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-Roman-to-Integer"><a href="#13-Roman-to-Integer" class="headerlink" title="13. Roman to Integer"></a>13. Roman to Integer</h3><p>Given a roman numeral, convert it to an integer.</p><p>Input is guaranteed to be within the range from 1 to 3999.</p><h4 id="问题-38"><a href="#问题-38" class="headerlink" title="问题"></a>问题</h4><p>转化罗马数字</p><h4 id="思路-35"><a href="#思路-35" class="headerlink" title="思路"></a>思路</h4><p>做一个字典，分小紧随大，大紧随小 两种罗马字符减加情况</p><h4 id="C-40"><a href="#C-40" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">    int romanToInt(string s)</span><br><span class="line">&#123;</span><br><span class="line">    unordered_map&lt;char, int&gt; map&#123;&#123;&apos;I&apos;, 1&#125;,</span><br><span class="line">                                 &#123;&apos;V&apos;, 5&#125;,</span><br><span class="line">                                 &#123;&apos;X&apos;, 10&#125;,</span><br><span class="line">                                 &#123;&apos;L&apos;, 50&#125;,</span><br><span class="line">                                 &#123;&apos;C&apos;, 100&#125;,</span><br><span class="line">                                 &#123;&apos;D&apos;, 500&#125;,</span><br><span class="line">                                 &#123;&apos;M&apos;, 1000&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    int res = 0;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; s.size(); i++) &#123;</span><br><span class="line">        if (map[s[i]]&lt;map[s[i+1]]) &#123;</span><br><span class="line">            res -= map[s[i]];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            res += map[s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="401-Binary-Watch"><a href="#401-Binary-Watch" class="headerlink" title="401. Binary Watch"></a>401. Binary Watch</h3><p>A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59).</p><p>Each LED represents a zero or one, with the least significant bit on the right.</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/8/8b/Binary_clock_samui_moon.jpg" alt="image"><br>For example, the above binary watch reads “3:25”.</p><p>Given a non-negative integer n which represents the number of LEDs that are currently on, return all possible times the watch could represent.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 1</span><br><span class="line">Return: [&quot;1:00&quot;, &quot;2:00&quot;, &quot;4:00&quot;, &quot;8:00&quot;, &quot;0:01&quot;, &quot;0:02&quot;, &quot;0:04&quot;, &quot;0:08&quot;, &quot;0:16&quot;, &quot;0:32&quot;]</span><br><span class="line">Note:</span><br><span class="line">The order of output does not matter.</span><br><span class="line">The hour must not contain a leading zero, for example &quot;01:00&quot; is not valid, it should be &quot;1:00&quot;.</span><br><span class="line">The minute must be consist of two digits and may contain a leading zero, for example &quot;10:2&quot; is not valid, it should be &quot;10:02&quot;.</span><br></pre></td></tr></table></figure><h4 id="问题-39"><a href="#问题-39" class="headerlink" title="问题"></a>问题</h4><p>二进制手表，当亮点个数为n时，给出所有时间组合</p><h4 id="思路-36"><a href="#思路-36" class="headerlink" title="思路"></a>思路</h4><p>二进制表示各时间，符合count则添加进返回vector</p><h4 id="C-41"><a href="#C-41" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; readBinaryWatch(int num) &#123;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    for(int h = 0; h &lt; 12;h++)</span><br><span class="line">        for(int m = 0; m &lt; 60;m++)&#123;</span><br><span class="line">            if (bitset&lt;10&gt;(h&lt;&lt;6|m).count() == num) &#123;</span><br><span class="line">                res.emplace_back(to_string(h) + (m&lt;10?&quot;:0&quot;:&quot;:&quot;)  + to_string(m));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获-23"><a href="#收获-23" class="headerlink" title="收获"></a>收获</h4><p>bitset<10></10></p><p>emplace_back 比 push_back 更高效</p><h3 id="206-Reverse-Linked-List"><a href="#206-Reverse-Linked-List" class="headerlink" title="206. Reverse Linked List"></a>206. Reverse Linked List</h3><h4 id="问题-40"><a href="#问题-40" class="headerlink" title="问题"></a>问题</h4><p>翻转链表</p><h4 id="思路-37"><a href="#思路-37" class="headerlink" title="思路"></a>思路</h4><p>设立一个pre指针，一个next指针，进行翻转</p><h4 id="C-42"><a href="#C-42" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    ListNode *a = NULL;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    while(head)&#123;</span><br><span class="line">        ListNode *tmp = head-&gt;next;</span><br><span class="line">        head-&gt;next = a;</span><br><span class="line">        a=head;</span><br><span class="line">        head=tmp;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###</p><h4 id="问题-41"><a href="#问题-41" class="headerlink" title="问题"></a>问题</h4><h4 id="思路-38"><a href="#思路-38" class="headerlink" title="思路"></a>思路</h4><h4 id="C-43"><a href="#C-43" class="headerlink" title="C++"></a>C++</h4><h4 id="收获-24"><a href="#收获-24" class="headerlink" title="收获"></a>收获</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;461-Hamming-Distance&quot;&gt;&lt;a href=&quot;#461-Hamming-Distance&quot; class=&quot;headerlink&quot; title=&quot;461. Hamming Distance&quot;&gt;&lt;/a&gt;461. Hamming Distance&lt;/h3
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://github.com/zhujiaxiang/zhujiaxiang.github.io/2018/07/23/hello-world/"/>
    <id>https://github.com/zhujiaxiang/zhujiaxiang.github.io/2018/07/23/hello-world/</id>
    <published>2018-07-23T07:40:58.583Z</published>
    <updated>2018-07-23T07:40:58.583Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>React Native</title>
    <link href="https://github.com/zhujiaxiang/zhujiaxiang.github.io/2018/07/23/React%20Native/"/>
    <id>https://github.com/zhujiaxiang/zhujiaxiang.github.io/2018/07/23/React Native/</id>
    <published>2018-07-23T02:16:00.101Z</published>
    <updated>2018-07-31T03:20:17.037Z</updated>
    
    <content type="html"><![CDATA[<h4 id="RN解决的问题"><a href="#RN解决的问题" class="headerlink" title="RN解决的问题"></a>RN解决的问题</h4><p>设计理念：使用React Native开发，既拥有Native的良好人机交互体验，又保留了React框架的开发效率（TODO:开发效率莫非很高？）。其提供的解决方案可以称为“一次学习，随处编写（Learn once,write anywhere）”</p><h4 id="重要特性与强项"><a href="#重要特性与强项" class="headerlink" title="重要特性与强项"></a>重要特性与强项</h4><p>1.一次学习，随处编写（开发思路相同，不同平台上的代码根据平台会有微小的区别，）<br>2.混合开发  </p><ul><li>UI与业务逻辑由React Native开发，与手机平台紧密关联的处理由原生执行  </li><li>可将UI控件包装为RN自定义组件  </li><li>RN界面与原生界面能自由切换<br>3.独特的UI实现框架，使用React开发，开发者只需关心数据，当数据改变时，只需通知React数据变了，由React来实现UI界面的改变（状态机变量与属性）<br>4.组件化开发<br>5.跨平台移植代码迅速（需要适配部分的代码只有总代码的5%甚至更低）<br>6.通过灵活的布局方式，适配不同屏幕大小的手机<br>7.高效的开发调试（做出改动不用重编译，可以立刻看到效果）<br>8.hotfix方便<br>9.包体积有效降低<br>10.开发语言简单（ES6,JSX），接近自然语言（和OC命名风格差不多）<br>11.积木式UI  <h4 id="代价"><a href="#代价" class="headerlink" title="代价"></a>代价</h4>1.内存消耗大<br>2.在最优条件下运行速度比原生代码慢，菜鸡来开发，RN甚至有优势  <h4 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h4>1.版本号的知识，递增规则如下以0.41为例（主版本号.次版本号）  </li><li>xcode安装  </li><li>brew install node  </li><li>brew install watchman  </li><li>npm install -g<br>2.IDEA选择：atom+nuclide/vscode<br>3.TODO:React Dev Tools安装</li></ul><h4 id="状态机思维与状态机变量"><a href="#状态机思维与状态机变量" class="headerlink" title="状态机思维与状态机变量"></a>状态机思维与状态机变量</h4><p>1.react-native init LearnRN 初始化项目<br>2.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;RN解决的问题&quot;&gt;&lt;a href=&quot;#RN解决的问题&quot; class=&quot;headerlink&quot; title=&quot;RN解决的问题&quot;&gt;&lt;/a&gt;RN解决的问题&lt;/h4&gt;&lt;p&gt;设计理念：使用React Native开发，既拥有Native的良好人机交互体验，又保留了React
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>机器学习常见名词解释</title>
    <link href="https://github.com/zhujiaxiang/zhujiaxiang.github.io/2018/06/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>https://github.com/zhujiaxiang/zhujiaxiang.github.io/2018/06/25/机器学习/</id>
    <published>2018-06-25T10:26:43.070Z</published>
    <updated>2018-07-23T09:22:48.718Z</updated>
    
    <content type="html"><![CDATA[<p>学习算法：在计算机上从数据中产生模型的算法<br>示例（样本）：数据集中每条关于一个事件或对象的记录<br>属性，特征：反映事件或对象在某方面的表现或性质的事项<br>属性值：属性上的取值<br>属性空间，样本空间，输入空间：属性张成的空间<br>特征向量：由于空间中的每个点对应一个坐标向量，因此我们把一个示例也称为特征向量<br>维数：一个示例Xi由N个属性来描述，我们便称样本有N维<br>学习，训练：从数据中学得模型的过程，这个过程通过执行某个学习算法来完成<br>训练数据：训练过程中使用的数据<br>训练样本：训练数据中的每一个示例（样本）<br>训练集：训练样本组成的集合<br>假设：学得模型对应了关于数据的某种潜在的规律<br>真相，真实：潜在规律的自身<br>学习器：模型的别称<br>预测：帮助判断某个假设（判断没剖开的是不是好瓜）<br>标记：示例结果的信息（好瓜，坏瓜）<br>样例：拥有了标记信息的示例<br>标记空间，输出空间：所有标记的集合<br>分类：预测的是离散值，例如“好瓜”，“坏瓜”<br>回归：预测的是连续值，例如西瓜成熟度0.95，0.98<br>正类，反类：只涉及两个类别的“二分类”任务<br>多分类：涉及多个类别时<br>测试：学得模型后，使用其进行预测的过程<br>测试样本：被预测的样本<br>聚类：将训练集中的训练样本瓜分成若干组<br>簇：每组称为一个簇，这些自动形成的簇可能对应一些潜在的概念<br>监督学习：训练数据有标记信息，代表为分类和回归<br>非监督学习：训练数据无标记信息，代表为聚类<br>泛化：学得模型适用于新样本的能力<br>独立同分布：获得的每个样本都是独立的从一个分布上采样获得的<br>归纳：从特殊到一般的泛化过程<br>演绎：从一般到特殊的特化过程<br>归纳学习：从样例中学习，归纳的过程，广义上的归纳学习大体相当于从样例中学习。狭义的归纳学习则要求从训练数据中学得概念，所以又称概念学习或概念形成。<br>假设空间：所有假设组成的空间<br>版本空间：与训练集一致（即对所有训练样本能够进行正确判断）的“假设集合”<br>归纳偏好：机器学习算法在学习过程中对某种类型假设的偏好，称为归纳偏好。例如模型更偏好根蒂来判断好瓜坏瓜。<br>奥卡姆剃刀：是一种常用的，自然科学研究中最基本的原则，即“若有多个假设与观察一致，则选最简单的那个”<br>没有免费的午餐定理NFL：无论算法多机智，期望性能相同<br>数据挖掘：从海量数据中发掘知识，对数据的管理和分析。<br>深度学习：狭义说是“很多层”的神经网络，缺乏严格的理论基础，设计的模型复杂度非常高，需要下功夫调参。<br>错误率与精度:分类错误的样本占样本总数的比例称为错误率，如果在m个样本中有a个样本分类错误，则错误率E=a/m；相应的1-a/m称为精度<br>过拟合：将训练样本自身的一些特点当做了所有潜在样本都会有的一般性质，这样就会导致泛化性能下降，称为过拟合。<br>欠拟合：与过拟合相对，对训练样本的一般性质尚未学好<br>评估方法-留出法：将训练集D划分为两个互斥的集合，其中一个集合作为训练集S。另一个作为测试集T，在S上训练处模型后，用T来评估其测试误差，作为对泛化误差的估计。不同的划分会导致不同的训练/测试集，所以单次使用留出法得到的估计结果往往不够稳定可靠，在使用留出法时，一般要采用若干次随即划分，重复进行实验评估后取平均值作为留出法的评估结果。<br>分层采样：保留类别比例的采样方式<br>交叉验证法（k折交叉验证）：先将数据集D划分为k个大小相似的互斥子集，每个子集都尽可能保持数据分布的一致性，即通过分层采样得到。每次用k-1个子集的并集作为训练集，余下的那个子集作为测试集，这样就可获得k组训练/测试集，从而可进行k次训练和测试，最终返回的事k个测试结果的均值。<br>自助法：我们希望评估的是D训练出的模型。但在留出法和交叉验证发中，由于保留了一部分样本用于测试，因此实际评估的模型所使用的训练集比D小，这必然会引入一些因训练样本规模不同二导致的估计偏差。对于给定包含m个样本的数据集D，我们对它采样产生数据集D‘：每次随即从D中挑选一个样本，将其拷贝放入D’，然后再将该样本放回初始数据集D中，使得该样本在下次采样时仍有可能被采到；这个过程重复执行m次后，我们就得到了包含m个样本的数据集D’，这就是自助采样的结果。显然。一部分样本会多次出现，另一部分不出现，样本在m次采样中始终不被采到的概率是（1-1/m）的m次方，取极限约等于0.368.于是我们将D’作为训练集，D/D’作为测试集，这样实际评估的模型与期望评估的模型都是用m个样本，而仍有数据总量三分之一的未在训练集中出现的样本用于测试，这样的测试结果也称作包外估计。自助法在数据集较小，难以划分训练/测试集时很有用。然而。自助法产生的数据改变了分布，引入了估计偏差，因此在初始数据量足够时，留出法和交叉验证法更常用。<br>错误率与精度：错误率是分类错误的样本数占样本总数的比例，精度=1-错误率<br>查准率与查全率：对于二分类问题，可将样例根据真实类别与学习期预测类别的组合划分为真正例（true positive），假正例（false positive），真反例（true negative），假反例（false negative）四种情形  </p><table><thead><tr><th>真实情况</th><th>正例</th><th>反例</th></tr></thead><tbody><tr><td>正例</td><td>TP(真正例)</td><td>FN(假反例)</td></tr><tr><td>反例</td><td>FP(假正例)</td><td>TN（真反例）</td></tr></tbody></table><p>查准率： P=TP/TP+FP<br>查全率： R=TP/TP+FN</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习算法：在计算机上从数据中产生模型的算法&lt;br&gt;示例（样本）：数据集中每条关于一个事件或对象的记录&lt;br&gt;属性，特征：反映事件或对象在某方面的表现或性质的事项&lt;br&gt;属性值：属性上的取值&lt;br&gt;属性空间，样本空间，输入空间：属性张成的空间&lt;br&gt;特征向量：由于空间中的每个
      
    
    </summary>
    
    
  </entry>
  
</feed>
