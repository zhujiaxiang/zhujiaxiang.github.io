<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lio&#39;s dream</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/zhujiaxiang/zhujiaxiang.github.io/"/>
  <updated>2018-08-01T10:06:12.171Z</updated>
  <id>https://github.com/zhujiaxiang/zhujiaxiang.github.io/</id>
  
  <author>
    <name>Lio</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>检测ibiu打包是否误打为debug的脚本</title>
    <link href="https://github.com/zhujiaxiang/zhujiaxiang.github.io/2018/08/01/%E6%A3%80%E6%B5%8Bibiu%E6%89%93%E5%8C%85%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9%E8%84%9A%E6%9C%AC/"/>
    <id>https://github.com/zhujiaxiang/zhujiaxiang.github.io/2018/08/01/检测ibiu打包配置选项脚本/</id>
    <published>2018-08-01T10:06:12.171Z</published>
    <updated>2018-08-01T10:06:12.171Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">#原理：根据上次出错经验，观察git文件变化规律，发现xxxmodule-umbrella.h文件会对打包方式进行标记。</span><br><span class="line">#思路：检查umbrella文件是否包含/*Debug*/字符。</span><br><span class="line">#输入：本脚本地址 空格 工程根目录。</span><br><span class="line">#输出：含有debug的umbrella.h文件路径 搜索完成返回 done</span><br><span class="line">#耗时：我的机器用了 1分45秒</span><br><span class="line"></span><br><span class="line">function scandir() &#123;</span><br><span class="line">local cur_dir parent_dir workdir target_dir</span><br><span class="line">workdir=$1</span><br><span class="line">target_dir=&quot;-umbrella.h&quot;</span><br><span class="line">cd $&#123;workdir&#125;</span><br><span class="line">if [ $&#123;workdir&#125; = &quot;/&quot; ]</span><br><span class="line">then</span><br><span class="line">cur_dir=&quot;&quot;</span><br><span class="line">else</span><br><span class="line">cur_dir=$(pwd)</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">for dirlist in $(ls $&#123;cur_dir&#125;)</span><br><span class="line">do</span><br><span class="line">if test -d $&#123;dirlist&#125;;then</span><br><span class="line">cd $&#123;dirlist&#125;</span><br><span class="line">scandir $&#123;cur_dir&#125;/$&#123;dirlist&#125;</span><br><span class="line">cd ..</span><br><span class="line">elif [[ $&#123;dirlist&#125; =~ $&#123;target_dir&#125; ]]</span><br><span class="line">then</span><br><span class="line">if [ `grep -c &quot;*Debug*&quot; $&#123;cur_dir&#125;/$&#123;dirlist&#125;` -gt &apos;0&apos; ]; then</span><br><span class="line"></span><br><span class="line">#echo &quot;Found!&quot;</span><br><span class="line">#else</span><br><span class="line">#echo &quot;Debug&quot;</span><br><span class="line">#fi</span><br><span class="line">echo $&#123;cur_dir&#125;/$&#123;dirlist&#125;</span><br><span class="line">fi</span><br><span class="line">fi</span><br><span class="line">done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if test -d $1</span><br><span class="line">then</span><br><span class="line">scandir $1</span><br><span class="line">echo &quot;done&quot;</span><br><span class="line">elif test -f $1</span><br><span class="line">then</span><br><span class="line">echo &quot;you input a file but not a directory,pls reinput and try again&quot;</span><br><span class="line">exit 1</span><br><span class="line">else</span><br><span class="line">echo &quot;the Directory isn&apos;t exist which you input,pls input a new one!!&quot;</span><br><span class="line">exit 1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCodePageTwo</title>
    <link href="https://github.com/zhujiaxiang/zhujiaxiang.github.io/2018/07/31/LeetCodePageTwo/"/>
    <id>https://github.com/zhujiaxiang/zhujiaxiang.github.io/2018/07/31/LeetCodePageTwo/</id>
    <published>2018-07-31T03:45:16.184Z</published>
    <updated>2018-07-31T03:45:16.184Z</updated>
    
    <content type="html"><![CDATA[<h3 id="350-Intersection-of-Two-Arrays-II"><a href="#350-Intersection-of-Two-Arrays-II" class="headerlink" title="350. Intersection of Two Arrays II"></a>350. Intersection of Two Arrays II</h3><p>Given two arrays, write a function to compute their intersection.</p><h4 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].</span><br></pre></td></tr></table></figure><h4 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h4><p>Each element in the result should appear as many times as it shows in both arrays.<br>The result can be in any order.</p><h4 id="Follow-up"><a href="#Follow-up" class="headerlink" title="Follow up:"></a>Follow up:</h4><p>What if the given array is already sorted? How would you optimize your algorithm?</p><p>What if nums1’s size is small compared to nums2’s size? Which algorithm is better?</p><p>What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>求出两个数组中全部重复的元素</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>使用unordered_map 进行统计++，随后再比较–</p><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">    </span><br><span class="line">    unordered_map&lt;int, int&gt; map;</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    for (int i=0; i&lt;nums1.size(); i++) &#123;</span><br><span class="line">        ++map[nums1[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int j = 0; j &lt; nums2.size(); j++) &#123;</span><br><span class="line">        if (--map[nums2[j]] &gt;= 0) &#123;</span><br><span class="line">            res.push_back(nums2[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="268-Missing-Number"><a href="#268-Missing-Number" class="headerlink" title="268. Missing Number"></a>268. Missing Number</h3><p>Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array.</p><h4 id="For-example"><a href="#For-example" class="headerlink" title="For example,"></a>For example,</h4><p>Given nums = [0, 1, 3] return 2.</p><h4 id="Note-1"><a href="#Note-1" class="headerlink" title="Note:"></a>Note:</h4><p>Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?</p><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><p>给一个顺序数组，找出遗失的数字</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>通过^找出遗失的数字，多出的数字一定等于数组长度</p><h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    int missingNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    </span><br><span class="line">    int result = (int)nums.size();</span><br><span class="line">    int i = 0;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    for(auto num:nums)</span><br><span class="line">    &#123;</span><br><span class="line">        result ^= num;</span><br><span class="line">        result ^= i;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="447-Number-of-Boomerangs"><a href="#447-Number-of-Boomerangs" class="headerlink" title="447. Number of Boomerangs"></a>447. Number of Boomerangs</h3><p>Given n points in the plane that are all pairwise distinct, a “boomerang” is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters).</p><p>Find the number of boomerangs. You may assume that n will be at most 500 and coordinates of points are all in the range [-10000, 10000] (inclusive).</p><h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example:"></a>Example:</h4><h4 id="Input"><a href="#Input" class="headerlink" title="Input:"></a>Input:</h4><p>[[0,0],[1,0],[2,0]]</p><h4 id="Output"><a href="#Output" class="headerlink" title="Output:"></a>Output:</h4><p>2</p><h4 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation:"></a>Explanation:</h4><p>The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]]</p><h4 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h4><p>给出一系列坐标，通过这些坐标问你能找出几组回旋镖数组？回旋镖数组的意思是中点到两点距离相同。</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>使用欧氏距离计算两点距离（不开方）</p><p>使用unordered_map存储 距离：相同距离的边数，</p><p>再使用排列组合将边数的组合数全部加起来</p><h4 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    int numberOfBoomerangs(vector&lt;pair&lt;int, int&gt;&gt;&amp; points) &#123;</span><br><span class="line">    </span><br><span class="line">    int res = 0;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; points.size(); i++) &#123;</span><br><span class="line">        </span><br><span class="line">        unordered_map&lt;long, int&gt; cnt;</span><br><span class="line">        </span><br><span class="line">        for (int j = 0; j &lt; points.size(); j++) &#123;</span><br><span class="line">            if(i == j) continue;</span><br><span class="line">            int dx = points[i].first - points[j].first;</span><br><span class="line">            int dy = points[i].second - points[j].second;</span><br><span class="line">            </span><br><span class="line">            int key = dx * dx;</span><br><span class="line">            key += dy * dy;</span><br><span class="line">            </span><br><span class="line">            ++cnt[key];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for (auto i : cnt) &#123;</span><br><span class="line">            res += i.second * (i.second - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="541-Reverse-String-II"><a href="#541-Reverse-String-II" class="headerlink" title="541. Reverse String II"></a>541. Reverse String II</h3><p>Given a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.</p><h4 id="Example-2"><a href="#Example-2" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">Output: &quot;bacdfeg&quot;</span><br></pre></td></tr></table></figure><h4 id="Restrictions"><a href="#Restrictions" class="headerlink" title="Restrictions:"></a>Restrictions:</h4><p>The string consists of lower English letters only.<br>Length of the given string and k will in the range [1, 10000]</p><h4 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h4><p>给一个数组s，每隔k位翻转字符</p><h4 id="C-3"><a href="#C-3" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">string reverseStr(string s, int k) &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    for(int i=0;i&lt;s.size(); i += 2*k)&#123;</span><br><span class="line">        reverse(s.begin()+i,min(s.begin()+i+k,s.end()) );</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return s;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h4><p>min(s.begin()+i+k,s.end())</p><h3 id="551-Student-Attendance-Record-I"><a href="#551-Student-Attendance-Record-I" class="headerlink" title="551. Student Attendance Record I"></a>551. Student Attendance Record I</h3><p>You are given a string representing an attendance record for a student. The record only contains the following three characters:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&apos;A&apos; : Absent.</span><br><span class="line">&apos;L&apos; : Late.</span><br><span class="line">&apos;P&apos; : Present.</span><br><span class="line">A student could be rewarded if his attendance record doesn&apos;t contain more than one &apos;A&apos; (absent) or more than two continuous &apos;L&apos; (late).</span><br><span class="line"></span><br><span class="line">You need to return whether the student could be rewarded according to his attendance record.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line">Input: &quot;PPALLP&quot;</span><br><span class="line">Output: True</span><br><span class="line">Example 2:</span><br><span class="line">Input: &quot;PPALLL&quot;</span><br><span class="line">Output: False</span><br></pre></td></tr></table></figure><h4 id="问题-4"><a href="#问题-4" class="headerlink" title="问题"></a>问题</h4><p>给一组数组，超过1个A或者连续2个L则输出false</p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>使用map进行统计，遇到L则检查前两位是否是L</p><h4 id="C-4"><a href="#C-4" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">bool checkRecord(string s) &#123;</span><br><span class="line">    </span><br><span class="line">    unordered_map&lt;char, int&gt; map;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; s.size(); i++) &#123;</span><br><span class="line">        if (i&gt;1&amp;&amp;s[i]==&apos;L&apos;) &#123;</span><br><span class="line">            if (s[i-1] == &apos;L&apos;&amp;&amp;s[i-2] == &apos;L&apos;) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (s[i] == &apos;A&apos; &amp;&amp; ++map[s[i]]&gt;1) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="别人写法"><a href="#别人写法" class="headerlink" title="别人写法"></a>别人写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool checkRecord(string s) &#123;</span><br><span class="line">    return !regex_search(s, regex(&quot;A.*A|LLL&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获-1"><a href="#收获-1" class="headerlink" title="收获"></a>收获</h4><p>regex_search(s, regex(“A.*A|LLL”)) 正则表达式   </p><h3 id="543-Diameter-of-Binary-Tree"><a href="#543-Diameter-of-Binary-Tree" class="headerlink" title="543. Diameter of Binary Tree"></a>543. Diameter of Binary Tree</h3><p>Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.</p><h4 id="Example-3"><a href="#Example-3" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Given a binary tree </span><br><span class="line">          1</span><br><span class="line">         / \</span><br><span class="line">        2   3</span><br><span class="line">       / \     </span><br><span class="line">      4   5    </span><br><span class="line">Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].</span><br></pre></td></tr></table></figure><h4 id="Note-The-length-of-path-between-two-nodes-is-represented-by-the-number-of-edges-between-them"><a href="#Note-The-length-of-path-between-two-nodes-is-represented-by-the-number-of-edges-between-them" class="headerlink" title="Note: The length of path between two nodes is represented by the number of edges between them."></a>Note: The length of path between two nodes is represented by the number of edges between them.</h4><h4 id="问题-5"><a href="#问题-5" class="headerlink" title="问题"></a>问题</h4><p>找出二叉树中任意两点的最长距离</p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>使用DFS遍历左右子树，将两棵树的深度相加</p><h4 id="C-5"><a href="#C-5" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int maxDepth = 0;</span><br><span class="line"></span><br><span class="line">int dfs(TreeNode * root)</span><br><span class="line">&#123;</span><br><span class="line">    if (root ==NULL) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    int leftDepth = dfs(root-&gt;left);</span><br><span class="line">    int rightDepth = dfs(root-&gt;right);</span><br><span class="line">    </span><br><span class="line">    if (leftDepth + rightDepth &gt; maxDepth) &#123;</span><br><span class="line">        maxDepth = leftDepth + rightDepth;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return max(leftDepth + 1, rightDepth + 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int diameterOfBinaryTree(TreeNode* root) &#123;</span><br><span class="line">    dfs(root);</span><br><span class="line">    return maxDepth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="108-Convert-Sorted-Array-to-Binary-Search-Tree"><a href="#108-Convert-Sorted-Array-to-Binary-Search-Tree" class="headerlink" title="108. Convert Sorted Array to Binary Search Tree"></a>108. Convert Sorted Array to Binary Search Tree</h3><p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p><h4 id="问题-6"><a href="#问题-6" class="headerlink" title="问题"></a>问题</h4><p>将有序数组转化为二叉搜索树</p><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>去数组的中位数作为root，递归构建左右子树</p><h4 id="C-6"><a href="#C-6" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    </span><br><span class="line">    if (nums.size() == 0) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (nums.size() == 1) &#123;</span><br><span class="line">        return new TreeNode(nums[0]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int middle = (int)nums.size()/2;</span><br><span class="line">    </span><br><span class="line">    TreeNode *root = new TreeNode(nums[middle]);</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; leftInt(nums.begin(),nums.begin() + middle);</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; rightInt(nums.begin()+middle+1,nums.end());</span><br><span class="line">    </span><br><span class="line">    root-&gt;left = sortedArrayToBST(leftInt);</span><br><span class="line">    root-&gt;right = sortedArrayToBST(rightInt);</span><br><span class="line">    </span><br><span class="line">    return root;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="415-Add-Strings"><a href="#415-Add-Strings" class="headerlink" title="415. Add Strings"></a>415. Add Strings</h3><p>Given two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2.</p><h4 id="Note-2"><a href="#Note-2" class="headerlink" title="Note:"></a>Note:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The length of both num1 and num2 is &lt; 5100.</span><br><span class="line">Both num1 and num2 contains only digits 0-9.</span><br><span class="line">Both num1 and num2 does not contain any leading zero.</span><br><span class="line">You must not use any built-in BigInteger library or convert the inputs to integer directly.</span><br></pre></td></tr></table></figure><h4 id="问题-7"><a href="#问题-7" class="headerlink" title="问题"></a>问题</h4><p>给2个用string表示的数字，将其相加并输出，</p><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>进位（carry）累加到下一位计算,将最终结果逆序输出</p><h4 id="C-7"><a href="#C-7" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">string addStrings(string num1, string num2) &#123;</span><br><span class="line">    int carry =0;</span><br><span class="line">    int i = (int)num1.size() - 1;</span><br><span class="line">    int j = (int)num2.size() - 1;</span><br><span class="line">    </span><br><span class="line">    string res = &quot;&quot;;</span><br><span class="line">    </span><br><span class="line">    while(i&gt;=0||j&gt;=0||carry)</span><br><span class="line">    &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        if(i&gt;=0) sum += (num1[i] - &apos;0&apos;) ; i--;</span><br><span class="line">        if(j&gt;=0) sum += (num2[j] - &apos;0&apos;) ; j--;</span><br><span class="line">        </span><br><span class="line">        sum += carry;</span><br><span class="line">        </span><br><span class="line">        carry = sum / 10;</span><br><span class="line">        sum = sum % 10;</span><br><span class="line">        </span><br><span class="line">        res = res + to_string(sum);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    reverse(res.begin(), res.end());</span><br><span class="line">    </span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="405-Convert-a-Number-to-Hexadecimal"><a href="#405-Convert-a-Number-to-Hexadecimal" class="headerlink" title="405. Convert a Number to Hexadecimal"></a>405. Convert a Number to Hexadecimal</h3><p>Given an integer, write an algorithm to convert it to hexadecimal. For negative integer, two’s complement method is used.</p><h4 id="Note-3"><a href="#Note-3" class="headerlink" title="Note:"></a>Note:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">All letters in hexadecimal (a-f) must be in lowercase.</span><br><span class="line">The hexadecimal string must not contain extra leading 0s. If the number is zero, it is represented by a single zero character &apos;0&apos;; otherwise, the first character in the hexadecimal string will not be the zero character.</span><br><span class="line">The given number is guaranteed to fit within the range of a 32-bit signed integer.</span><br><span class="line">You must not use any method provided by the library which converts/formats the number to hex directly.</span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">26</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;1a&quot;</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">-1</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;ffffffff&quot;</span><br></pre></td></tr></table></figure><h4 id="问题-8"><a href="#问题-8" class="headerlink" title="问题"></a>问题</h4><p>将数转化为16进制数</p><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p>十进制&amp;15 输出的结果为对应16进制数的最后4位对应的十进制数</p><h4 id="C-8"><a href="#C-8" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">string toHex(int num) &#123;</span><br><span class="line">        int count = 0;</span><br><span class="line">        if(!num) return &quot;0&quot;;</span><br><span class="line">        string result;</span><br><span class="line">        while (num &amp;&amp; count &lt; 8)</span><br><span class="line">        &#123;</span><br><span class="line">            int temp = num &amp; 15;</span><br><span class="line">            if (temp&lt;10)    result.push_back(&apos;0&apos;+ temp);</span><br><span class="line">            else result.push_back(&apos;a&apos;+temp-10);</span><br><span class="line">            num = num &gt;&gt; 4;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(result.begin(),result.end());</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="收获-2"><a href="#收获-2" class="headerlink" title="收获"></a>收获</h4><p>num &amp; 15 转化16进制</p><h3 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121. Best Time to Buy and Sell Stock"></a>121. Best Time to Buy and Sell Stock</h3><p>Say you have an array for which the ith element is the price of a given stock on day i.</p><p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: [7, 1, 5, 3, 6, 4]</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><p>max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line">Input: [7, 6, 4, 3, 1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><p>In this case, no transaction is done, i.e. max profit = 0.</p><h4 id="问题-9"><a href="#问题-9" class="headerlink" title="问题"></a>问题</h4><p>给一组数组，a[i]代表第i天的股票价格，问只能进行一次买卖的话怎么样才能获得最大收益。</p><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p>每次取一个日期，遍历求出他能取得的最大收益，直到所有日期取完</p><h4 id="C-9"><a href="#C-9" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">    int maximum = 0;</span><br><span class="line">    for(int i = 0; i &lt; prices.size();i++)&#123;</span><br><span class="line">        int pre = prices[i];</span><br><span class="line">        </span><br><span class="line">        int j = i + 1;</span><br><span class="line">        while (j&lt;prices.size()&amp;&amp;prices[j]&gt;prices[i]) &#123;</span><br><span class="line">            maximum = max(maximum, prices[j]-pre);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return maximum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="202-Happy-Number"><a href="#202-Happy-Number" class="headerlink" title="202. Happy Number"></a>202. Happy Number</h3><p>Write an algorithm to determine if a number is “happy”.</p><p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p><p>Example: 19 is a happy number</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1^2 + 9^2 = 82</span><br><span class="line">8^2 + 2^2 = 68</span><br><span class="line">6^2 + 8^2 = 100</span><br><span class="line">1^2 + 0^2 + 0^2 = 1</span><br></pre></td></tr></table></figure><h4 id="问题-10"><a href="#问题-10" class="headerlink" title="问题"></a>问题</h4><p>找出happy number</p><h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><p>非happy number会出现循环解（听过insert进set的成功与否 来探查）</p><h4 id="C-10"><a href="#C-10" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bool isHappy(int n) &#123;</span><br><span class="line"></span><br><span class="line">    set&lt;int&gt; loopDetectSet;</span><br><span class="line">    int sum;</span><br><span class="line">    while (n!=1&amp;&amp;loopDetectSet.insert(n).second) &#123;</span><br><span class="line">         sum = 0;</span><br><span class="line">        while (n&gt;0) &#123;</span><br><span class="line">            sum = sum + (n%10) * (n%10);</span><br><span class="line">            n=n/10;</span><br><span class="line">        &#125;</span><br><span class="line">        n = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return n == 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获-3"><a href="#收获-3" class="headerlink" title="收获"></a>收获</h4><p>从数理角度考虑，数学归纳法？</p><h3 id="326-Power-of-Three"><a href="#326-Power-of-Three" class="headerlink" title="326. Power of Three"></a>326. Power of Three</h3><p>Given an integer, write a function to determine if it is a power of three.</p><p>Follow up:<br>Could you do it without using any loop / recursion?</p><h4 id="问题-11"><a href="#问题-11" class="headerlink" title="问题"></a>问题</h4><p>求一个数是否是三的倍数</p><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><p>log10（n）/log10（3）是否为整数</p><h4 id="C-11"><a href="#C-11" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool isPowerOfThree(int n) &#123;</span><br><span class="line">    return  fmod(log10(n)/log10(3), 1)  == 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="231-Power-of-Two"><a href="#231-Power-of-Two" class="headerlink" title="231. Power of Two"></a>231. Power of Two</h3><p>同上</p><h3 id="83-Remove-Duplicates-from-Sorted-List"><a href="#83-Remove-Duplicates-from-Sorted-List" class="headerlink" title="83. Remove Duplicates from Sorted List"></a>83. Remove Duplicates from Sorted List</h3><p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">For example,</span><br><span class="line">Given 1-&gt;1-&gt;2, return 1-&gt;2.</span><br><span class="line">Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3.</span><br></pre></td></tr></table></figure><h4 id="问题-12"><a href="#问题-12" class="headerlink" title="问题"></a>问题</h4><p>删除重复的结点</p><h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><h4 id="C-12"><a href="#C-12" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ListNode* deleteDuplicates(ListNode* head) &#123;</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    </span><br><span class="line">    while(cur!=NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        while (cur-&gt;next&amp;&amp;(cur-&gt;val == cur-&gt;next-&gt;val)) &#123;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return head;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="35-Search-Insert-Position"><a href="#35-Search-Insert-Position" class="headerlink" title="35. Search Insert Position"></a>35. Search Insert Position</h3><p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p><p>You may assume no duplicates in the array.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Here are few examples.</span><br><span class="line">[1,3,5,6], 5 → 2</span><br><span class="line">[1,3,5,6], 2 → 1</span><br><span class="line">[1,3,5,6], 7 → 4</span><br><span class="line">[1,3,5,6], 0 → 0</span><br></pre></td></tr></table></figure><h4 id="问题-13"><a href="#问题-13" class="headerlink" title="问题"></a>问题</h4><p>插入数字，返回位置</p><h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4><p>常规解法不提，提一提二分查找</p><h4 id="C-13"><a href="#C-13" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">    int low = 0;</span><br><span class="line">    int high = (int)nums.size() -1;</span><br><span class="line">    </span><br><span class="line">    while(low&lt;=high)&#123;</span><br><span class="line">        int mid = low + (low + high)/2;</span><br><span class="line">        if (target &lt; nums[mid]) &#123;</span><br><span class="line">            high = mid-1 ;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            low = mid +1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return low;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="437-Path-Sum-III"><a href="#437-Path-Sum-III" class="headerlink" title="437. Path Sum III"></a>437. Path Sum III</h3><p>You are given a binary tree in which each node contains an integer value.</p><p>Find the number of paths that sum to a given value.</p><p>The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).</p><p>The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</span><br><span class="line"></span><br><span class="line">      10</span><br><span class="line">     /  \</span><br><span class="line">    5   -3</span><br><span class="line">   / \    \</span><br><span class="line">  3   2   11</span><br><span class="line"> / \   \</span><br><span class="line">3  -2   1</span><br><span class="line"></span><br><span class="line">Return 3. The paths that sum to 8 are:</span><br><span class="line"></span><br><span class="line">1.  5 -&gt; 3</span><br><span class="line">2.  5 -&gt; 2 -&gt; 1</span><br><span class="line">3. -3 -&gt; 11</span><br></pre></td></tr></table></figure><h4 id="问题-14"><a href="#问题-14" class="headerlink" title="问题"></a>问题</h4><p>树种结点组合成指定数字的组合数，只能由父到子</p><h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h4><p>两次递归</p><h4 id="C-14"><a href="#C-14" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">    int pathSum(TreeNode* root, int sum) &#123;</span><br><span class="line">    </span><br><span class="line">    if(root == NULL) return 0;</span><br><span class="line">    return sumUp(root, 0, sum) + pathSum(root-&gt;left, sum) + pathSum(root-&gt;right, sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sumUp(TreeNode *root,int pre,int sum)</span><br><span class="line">&#123;</span><br><span class="line">    if(root == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int current = pre + root-&gt;val;</span><br><span class="line">    return (current == sum) + sumUp(root-&gt;left, current, sum) + sumUp(root-&gt;right, current, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="70-Climbing-Stairs"><a href="#70-Climbing-Stairs" class="headerlink" title="70. Climbing Stairs"></a>70. Climbing Stairs</h3><p>You are climbing a stair case. It takes n steps to reach to the top.</p><p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p><p>Note: Given n will be a positive integer.</p><h4 id="问题-15"><a href="#问题-15" class="headerlink" title="问题"></a>问题</h4><p>爬楼梯，一次只能爬1或者2，求有多少种爬法</p><h4 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h4><p>斐波那契数列</p><h4 id="C-15"><a href="#C-15" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   int climbStairs(int n) &#123;</span><br><span class="line">    int a= 0,b=1;</span><br><span class="line">    while (n--) &#123;</span><br><span class="line">        b = b+a;</span><br><span class="line">        a = b-a;</span><br><span class="line">    &#125;</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获-4"><a href="#收获-4" class="headerlink" title="收获"></a>收获</h4><p>###</p><h4 id="问题-16"><a href="#问题-16" class="headerlink" title="问题"></a>问题</h4><h4 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h4><h4 id="C-16"><a href="#C-16" class="headerlink" title="C++"></a>C++</h4><h4 id="收获-5"><a href="#收获-5" class="headerlink" title="收获"></a>收获</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;350-Intersection-of-Two-Arrays-II&quot;&gt;&lt;a href=&quot;#350-Intersection-of-Two-Arrays-II&quot; class=&quot;headerlink&quot; title=&quot;350. Intersection of Two A
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCodePageOne</title>
    <link href="https://github.com/zhujiaxiang/zhujiaxiang.github.io/2018/07/31/LeetCodePageOne/"/>
    <id>https://github.com/zhujiaxiang/zhujiaxiang.github.io/2018/07/31/LeetCodePageOne/</id>
    <published>2018-07-31T03:44:12.411Z</published>
    <updated>2018-07-31T03:44:54.223Z</updated>
    
    <content type="html"><![CDATA[<h3 id="461-Hamming-Distance"><a href="#461-Hamming-Distance" class="headerlink" title="461. Hamming Distance"></a>461. Hamming Distance</h3><p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different.</p><p>Given two integers x and y, calculate the Hamming distance.</p><h3 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h3><p>0 ≤ x, y &lt; 231.</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: x = 1, y = 4</span><br><span class="line"></span><br><span class="line">Output: 2</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">1   (0 0 0 1)</span><br><span class="line">4   (0 1 0 0)</span><br><span class="line">       ↑   ↑</span><br></pre></td></tr></table></figure><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>求两个数的二进制表示中，不同位数的个数。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>将两个数进行异或</li><li>统计异或后的数字中1的个数<h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int hammingDistance(int x, int y) &#123;</span><br><span class="line">        int dist = 0; int n = x^y;  //异或</span><br><span class="line">        while(n)</span><br><span class="line">        &#123;</span><br><span class="line">            ++dist;</span><br><span class="line">            n = n&amp;(n-1);</span><br><span class="line">        &#125;</span><br><span class="line">        return dist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="476-Number-Complement"><a href="#476-Number-Complement" class="headerlink" title="476. Number Complement"></a>476. Number Complement</h3><p>Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.</p><p>The above arrows point to positions where the corresponding bits are different.</p><h4 id="Note-1"><a href="#Note-1" class="headerlink" title="Note:"></a>Note:</h4><p>The given integer is guaranteed to fit within the range of a 32-bit signed integer.<br>You could assume no leading zero bit in the integer’s binary representation.</p><h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2</span><br></pre></td></tr></table></figure><h4 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 1</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.</span><br></pre></td></tr></table></figure><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>取一个正整数的二进制表达的反</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>制作一个mask 将正整数的二进制位数对应的位数 置为0；</li><li>将正整数取反 与 ~mask(00000000111)作与运算</li></ol><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findComplement(int num) &#123;</span><br><span class="line">      unsigned mask = ~0;             //制作mask</span><br><span class="line">        while (num &amp; mask) mask &lt;&lt;= 1;//根据正整数的二进制位数 将mask对应的位数置为0；</span><br><span class="line">        return ~mask &amp; ~num;          //将正整数取反，与mask作与运算</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="190-Reverse-Bits"><a href="#190-Reverse-Bits" class="headerlink" title="190. Reverse Bits"></a>190. Reverse Bits</h3><p>Reverse bits of a given 32 bits unsigned integer.</p><h4 id="For-example"><a href="#For-example" class="headerlink" title="For example"></a>For example</h4><p>given<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input 43261596 (represented in binary as 00000010100101000001111010011100)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">, return 964176192 (represented in binary as 00111001011110000010100101000000).</span><br></pre></td></tr></table></figure><h4 id="Follow-up"><a href="#Follow-up" class="headerlink" title="Follow up:"></a>Follow up:</h4><p>If this function is called many times, how would you optimize it?</p><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><p>反转比特</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>每次取最后一位加入result</li><li>再将imput右移抛出已加入的数字</li></ol><h3 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> uint32_t reverseBits(uint32_t input)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t result = 0;</span><br><span class="line">    const uint32_t BITS_OF_BYTES = 8 ;</span><br><span class="line">    for (int i=0; i&lt;sizeof(input)*BITS_OF_BYTES; i++) &#123;</span><br><span class="line">        result = (result &lt;&lt; 1 )|(input &amp; 1);            //result左移空出位置，将input最后一位加入</span><br><span class="line">        input = input &gt;&gt; 1;                            //input右移</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="500-Keyboard-Row"><a href="#500-Keyboard-Row" class="headerlink" title="500. Keyboard Row"></a>500. Keyboard Row</h3><p>Given a List of words, return the words that can be typed using letters of alphabet on only one row’s of American keyboard like the image below.<br><img src="https://leetcode.com/static/images/problemset/keyboard.png" alt="image"></p><h4 id="Example-1-1"><a href="#Example-1-1" class="headerlink" title="Example 1:"></a>Example 1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;Hello&quot;, &quot;Alaska&quot;, &quot;Dad&quot;, &quot;Peace&quot;]</span><br><span class="line">Output: [&quot;Alaska&quot;, &quot;Dad&quot;]</span><br></pre></td></tr></table></figure><h4 id="Note-2"><a href="#Note-2" class="headerlink" title="Note:"></a>Note:</h4><p>You may use one character in the keyboard more than once.</p><p>You may assume the input string will only contain letters of alphabet.</p><h4 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h4><p>给你一列表的单词，返回那些只包含美式键盘一行的单词</p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>查每个单词的第一个字母，将其设为某行，随后遍历每个字母，看是否都在那一行</p><h4 id="C-3"><a href="#C-3" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; findWords(std::vector&lt;std::string&gt; &amp;words)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    std::unordered_set&lt;char&gt; set1 = &#123;&apos;q&apos;, &apos;w&apos;, &apos;e&apos;, &apos;r&apos;, &apos;t&apos;, &apos;y&apos;, &apos;u&apos;, &apos;i&apos;, &apos;o&apos;, &apos;p&apos;&#125;;</span><br><span class="line">    std::unordered_set&lt;char&gt; set2 = &#123;&apos;a&apos;, &apos;s&apos;, &apos;d&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;&#125;;</span><br><span class="line">    std::unordered_set&lt;char&gt; set3 = &#123;&apos;z&apos;, &apos;x&apos;, &apos;c&apos;, &apos;v&apos;, &apos;b&apos;, &apos;n&apos;, &apos;m&apos;&#125;;</span><br><span class="line">    std::vector&lt;std::unordered_set&lt;char&gt;&gt; sets = &#123;set1, set2, set3&#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::string&gt; result;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; words.size(); i++) &#123;</span><br><span class="line">        int index = 0, flag = 0;</span><br><span class="line">        if (set1.find(tolower(words[i][0])) != set1.end()) &#123;</span><br><span class="line">            index = 0;</span><br><span class="line">        &#125; else if (set2.find(tolower(words[i][0])) != set2.end()) &#123;</span><br><span class="line">            index = 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            index = 2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::unordered_set&lt;char&gt; tempset = sets[index];</span><br><span class="line"></span><br><span class="line">        for (char a : words[i]) &#123;</span><br><span class="line">            if (tempset.find(tolower(a)) == tempset.end()) &#123;</span><br><span class="line">                flag = 1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (flag == 0) &#123;</span><br><span class="line">            result.push_back(words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h4><p>==using namespace std; or using std::xxxxx；==</p><h3 id="412-Fizz-Buzz"><a href="#412-Fizz-Buzz" class="headerlink" title="412. Fizz Buzz"></a>412. Fizz Buzz</h3><p>Write a program that outputs the string representation of numbers from 1 to n.</p><p>But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.</p><h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">n = 15,</span><br><span class="line"></span><br><span class="line">Return:</span><br><span class="line">[</span><br><span class="line">    &quot;1&quot;,</span><br><span class="line">    &quot;2&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;4&quot;,</span><br><span class="line">    &quot;Buzz&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;7&quot;,</span><br><span class="line">    &quot;8&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;Buzz&quot;,</span><br><span class="line">    &quot;11&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;13&quot;,</span><br><span class="line">    &quot;14&quot;,</span><br><span class="line">    &quot;FizzBuzz&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="问题-4"><a href="#问题-4" class="headerlink" title="问题"></a>问题</h4><p>给一个N 从1到n中的数 放入数组，如果是三的倍数输出Fizz，五的倍数输出Buzz，三五的倍数输出FizzBuzz</p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>分支判断</p><h4 id="C-4"><a href="#C-4" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; fizzBuzz(int n)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;string&gt; a;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        if (i%15==0) &#123;</span><br><span class="line">            a.push_back(&quot;FizzBuzz&quot;);</span><br><span class="line">        &#125;else if (i%5==0)&#123;</span><br><span class="line">            a.push_back(&quot;Buzz&quot;);</span><br><span class="line">        &#125;else if (i%3==0)&#123;</span><br><span class="line">            a.push_back(&quot;Fizz&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            a.push_back(to_string(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获-1"><a href="#收获-1" class="headerlink" title="收获"></a>收获</h4><p>==to_string()== int=&gt;string</p><h4 id="别人写法"><a href="#别人写法" class="headerlink" title="别人写法"></a>别人写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; fizzBuzz(int n) &#123;</span><br><span class="line">        vector&lt;string&gt; ret_vec(n);</span><br><span class="line">        for(int i=1; i&lt;=n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i%3 == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                ret_vec[i-1] += string(&quot;Fizz&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if(i%5 == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                ret_vec[i-1] += string(&quot;Buzz&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if(ret_vec[i-1] == &quot;&quot;)</span><br><span class="line">            &#123;</span><br><span class="line">                ret_vec[i-1] += to_string(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret_vec;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="344-Reverse-String"><a href="#344-Reverse-String" class="headerlink" title="344. Reverse String"></a>344. Reverse String</h3><p>Write a function that takes a string as input and returns the string reversed.</p><h4 id="Example-2"><a href="#Example-2" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given s = &quot;hello&quot;, return &quot;olleh&quot;.</span><br></pre></td></tr></table></figure><h3 id="C-5"><a href="#C-5" class="headerlink" title="C++"></a>C++</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">string reverseString(string s) &#123;</span><br><span class="line">    </span><br><span class="line">    if(s==&quot;&quot;)&#123;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125; ;</span><br><span class="line">    string result = &quot;&quot;;</span><br><span class="line">    int length = (int)s.length();</span><br><span class="line">    </span><br><span class="line">    if(length != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = length; i&gt;0; i--) &#123;</span><br><span class="line">            char temp = s[i-1];</span><br><span class="line">            result+=temp;       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="别人写法-1"><a href="#别人写法-1" class="headerlink" title="别人写法"></a>别人写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string reverseString(string s) &#123;</span><br><span class="line">       int i = 0, j = s.size() - 1;</span><br><span class="line">       while(i &lt; j)&#123;</span><br><span class="line">           swap(s[i++], s[j--]); </span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       return s;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="收获-2"><a href="#收获-2" class="headerlink" title="收获"></a>收获</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swap函数</span><br></pre></td></tr></table></figure><h3 id="496-Next-Greater-Element-I"><a href="#496-Next-Greater-Element-I" class="headerlink" title="496. Next Greater Element I"></a>496. Next Greater Element I</h3><p>You are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1’s elements in the corresponding places of nums2.</p><p>The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number.</p><h4 id="Example-1-2"><a href="#Example-1-2" class="headerlink" title="Example 1:"></a>Example 1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [4,1,2], nums2 = [1,3,4,2].</span><br><span class="line">Output: [-1,3,-1]</span><br><span class="line">Explanation:</span><br><span class="line">    For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.</span><br><span class="line">    For number 1 in the first array, the next greater number for it in the second array is 3.</span><br><span class="line">    For number 2 in the first array, there is no next greater number for it in the second array, so output -1.</span><br></pre></td></tr></table></figure><h4 id="Example-2-1"><a href="#Example-2-1" class="headerlink" title="Example 2:"></a>Example 2:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [2,4], nums2 = [1,2,3,4].</span><br><span class="line">Output: [3,-1]</span><br><span class="line">Explanation:</span><br><span class="line">    For number 2 in the first array, the next greater number for it in the second array is 3.</span><br><span class="line">    For number 4 in the first array, there is no next greater number for it in the second array, so output -1.</span><br></pre></td></tr></table></figure><h4 id="Note-3"><a href="#Note-3" class="headerlink" title="Note:"></a>Note:</h4><p>All elements in nums1 and nums2 are unique.</p><p>The length of both nums1 and nums2 would not exceed 1000.</p><h3 id="C-6"><a href="#C-6" class="headerlink" title="C++"></a>C++</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; findNums, vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int n = findNums.size();</span><br><span class="line">    int m = nums.size();</span><br><span class="line">    vector&lt;int&gt; result(n);</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;m;j++)&#123;</span><br><span class="line">            if (findNums[i] == nums[j]) &#123;</span><br><span class="line"></span><br><span class="line">                for (int k=j; k&lt;m; k++) &#123;</span><br><span class="line">                    if (nums[k]&gt;findNums[i]) &#123;</span><br><span class="line">                        result[i]=nums[k];</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                if (!result[i]) &#123;</span><br><span class="line">                    result[i]=-1;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                break;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                result[i] = -1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="别人写法-2"><a href="#别人写法-2" class="headerlink" title="别人写法"></a>别人写法</h3><p>通过建立一个键值对，预先保存nums中每个数的nextGreaterElement，随后对其进行查找。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line"> vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; findNums, vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">unordered_map&lt;int, int&gt; mark;</span><br><span class="line">deque&lt;int&gt; next;</span><br><span class="line">for (auto i : nums)&#123;</span><br><span class="line">while (!next.empty() &amp;&amp; i &gt; next.back())&#123;</span><br><span class="line">mark[next.back()] = i;</span><br><span class="line">next.pop_back();</span><br><span class="line">&#125;</span><br><span class="line">next.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;int &gt;res;</span><br><span class="line">for (auto i : findNums)&#123;</span><br><span class="line">if (mark.find(i) != mark.end())&#123;</span><br><span class="line">res.push_back(mark[i]);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">res.push_back(-1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="463-Island-Perimeter"><a href="#463-Island-Perimeter" class="headerlink" title="463. Island Perimeter"></a>463. Island Perimeter</h3><p>You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn’t have “lakes” (water inside that isn’t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island.</p><h4 id="Example-3"><a href="#Example-3" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[[0,1,0,0],</span><br><span class="line"> [1,1,1,0],</span><br><span class="line"> [0,1,0,0],</span><br><span class="line"> [1,1,0,0]]</span><br><span class="line"></span><br><span class="line">Answer: 16</span><br><span class="line">Explanation: The perimeter is the 16 yellow stripes in the image below:</span><br></pre></td></tr></table></figure><p><img src="https://leetcode.com/static/images/problemset/island.png" alt="image"></p><h4 id="问题-5"><a href="#问题-5" class="headerlink" title="问题"></a>问题</h4><p>0是海1是岛，求岛的边界</p><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>从非边缘行，列开始遍历，遍历到1，count++，检查其左上两个是否也为一，若为1记录为一个repeat，</p><h4 id="C-7"><a href="#C-7" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    int repeat = 0;</span><br><span class="line">    for (int i=0; i&lt;grid.size(); i++) &#123;</span><br><span class="line">        for (int j=0; j&lt;grid[i].size(); j++) &#123;</span><br><span class="line">            if (grid[i][j] == 1) &#123;</span><br><span class="line">                count ++;</span><br><span class="line">                if (j!=0 &amp;&amp; grid[i][j-1] == 1) &#123;</span><br><span class="line">                    repeat ++;</span><br><span class="line">                &#125;</span><br><span class="line">                if (i!=0 &amp;&amp; grid[i-1][j] == 1) &#123;</span><br><span class="line">                    repeat ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return count * 4 -repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获-3"><a href="#收获-3" class="headerlink" title="收获"></a>收获</h4><p>遍历二维vector的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int i=0; i&lt;grid.size(); i++) </span><br><span class="line">&#123;</span><br><span class="line">        for (int j=0; j&lt;grid[i].size(); j++) </span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="292-Nim-Game"><a href="#292-Nim-Game" class="headerlink" title="292. Nim Game"></a>292. Nim Game</h3><p>You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.</p><p>Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.</p><p>For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.</p><h4 id="Hint"><a href="#Hint" class="headerlink" title="Hint:"></a>Hint:</h4><p>If there are 5 stones in the heap, could you figure out a way to remove the stones such that you will always be the winner?</p><h4 id="问题-6"><a href="#问题-6" class="headerlink" title="问题"></a>问题</h4><p>取石头 一个人能取1，2，3块石头，如果你是先手，判断是否能赢</p><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>是4的倍数必输</p><h4 id="C-8"><a href="#C-8" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool canWinNim(int n) &#123;</span><br><span class="line">        return (n &amp;0B11) != 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="收获-4"><a href="#收获-4" class="headerlink" title="收获"></a>收获</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(n % 4) != 0 </span><br><span class="line">(n &amp;0B11) != 0;</span><br></pre></td></tr></table></figure><h3 id="485-Max-Consecutive-Ones"><a href="#485-Max-Consecutive-Ones" class="headerlink" title="485. Max Consecutive Ones"></a>485. Max Consecutive Ones</h3><p>Given a binary array, find the maximum number of consecutive 1s in this array.</p><h4 id="Example-1-3"><a href="#Example-1-3" class="headerlink" title="Example 1:"></a>Example 1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,0,1,1,1]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The first two digits or the last three digits are consecutive 1s.</span><br><span class="line">    The maximum number of consecutive 1s is 3.</span><br></pre></td></tr></table></figure><h4 id="Note-4"><a href="#Note-4" class="headerlink" title="Note:"></a>Note:</h4><p>The input array will only contain 0 and 1.</p><p>The length of input array is a positive integer and will not exceed 10,000</p><h4 id="问题-7"><a href="#问题-7" class="headerlink" title="问题"></a>问题</h4><p>求最长的连续1的数量</p><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p>做一个mark数组标记0的位置，再进行处理</p><h4 id="C-9"><a href="#C-9" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int findMaxConsecutiveOnes(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">   vector&lt;int&gt; mark;</span><br><span class="line">   int count = 0;</span><br><span class="line">   mark.push_back(-1);</span><br><span class="line">   for(int i=0;i&lt;nums.size();i++)&#123;</span><br><span class="line">       if (nums[i] == 0) &#123;</span><br><span class="line">           mark.push_back(i);</span><br><span class="line">           count ++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   if(count == 0)&#123;</span><br><span class="line">       return (int)nums.size();</span><br><span class="line">   &#125;</span><br><span class="line">   mark.push_back(nums.size());</span><br><span class="line">   int max = 0;</span><br><span class="line">   for (int j=1; j&lt;mark.size(); j++) &#123;</span><br><span class="line">       if (mark[j]-mark[j-1] -1 &gt;max) &#123;</span><br><span class="line">           max = mark[j]-mark[j-1]-1;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return max;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h4 id="别人写法-3"><a href="#别人写法-3" class="headerlink" title="别人写法"></a>别人写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int findMaxConsecutiveOnes(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">int max=0,cur=0;</span><br><span class="line">for(int i=0;i&lt;nums.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">if(nums[i]&amp;1)</span><br><span class="line">&#123;</span><br><span class="line">max=max&gt;++cur?max:cur;</span><br><span class="line">&#125;</span><br><span class="line">else cur=0;</span><br><span class="line">&#125;</span><br><span class="line">return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获-5"><a href="#收获-5" class="headerlink" title="收获"></a>收获</h4><p>别想太复杂</p><h3 id="136-Single-Number"><a href="#136-Single-Number" class="headerlink" title="136. Single Number"></a>136. Single Number</h3><p>Given an array of integers, every element appears twice except for one. Find that single one.</p><h4 id="Note-5"><a href="#Note-5" class="headerlink" title="Note:"></a>Note:</h4><p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p><h4 id="问题-8"><a href="#问题-8" class="headerlink" title="问题"></a>问题</h4><p>求一个数组中的单个数字，要求线性时间复杂度，无额外空间</p><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p>异或为0</p><h4 id="C-10"><a href="#C-10" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">            for(int i=1;i&lt;nums.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[0]=nums[0]^nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return nums[0];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="收获-6"><a href="#收获-6" class="headerlink" title="收获"></a>收获</h4><p>多关注位运算，异或，与，非，反</p><h3 id="448-Find-All-Numbers-Disappeared-in-an-Array"><a href="#448-Find-All-Numbers-Disappeared-in-an-Array" class="headerlink" title="448. Find All Numbers Disappeared in an Array"></a>448. Find All Numbers Disappeared in an Array</h3><p>Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.</p><p>Find all the elements of [1, n] inclusive that do not appear in this array.</p><p>Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.</p><h4 id="Example-4"><a href="#Example-4" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[5,6]</span><br></pre></td></tr></table></figure><h4 id="问题-9"><a href="#问题-9" class="headerlink" title="问题"></a>问题</h4><p>寻找数组中消失的数字</p><h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><p>把数字放到该放的地方，然后找出消失的数字</p><h4 id="C-11"><a href="#C-11" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int len = (int)nums.size();</span><br><span class="line">    for (int i=0; i&lt;len; i++) &#123;</span><br><span class="line">        int m = abs(nums[i])-1;</span><br><span class="line">        nums[m]= nums[m]&gt;0?-nums[m]:nums[m];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    for (int i=0; i&lt;len; i++) &#123;</span><br><span class="line">        if(nums[i] &gt; 0) res.push_back(i+1);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="520-Detect-Capital"><a href="#520-Detect-Capital" class="headerlink" title="520. Detect Capital"></a>520. Detect Capital</h3><p>Given a word, you need to judge whether the usage of capitals in it is right or not.</p><p>We define the usage of capitals in a word to be right when one of the following cases holds:</p><p>All letters in this word are capitals, like “USA”.<br>All letters in this word are not capitals, like “leetcode”.<br>Only the first letter in this word is capital if it has more than one letter, like “Google”.<br>Otherwise, we define that this word doesn’t use capitals in a right way.</p><h4 id="Example-1-4"><a href="#Example-1-4" class="headerlink" title="Example 1:"></a>Example 1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;USA&quot;</span><br><span class="line">Output: True</span><br></pre></td></tr></table></figure><h4 id="Example-2-2"><a href="#Example-2-2" class="headerlink" title="Example 2:"></a>Example 2:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;FlaG&quot;</span><br><span class="line">Output: False</span><br></pre></td></tr></table></figure><h4 id="Note-6"><a href="#Note-6" class="headerlink" title="Note:"></a>Note:</h4><p>The input will be a non-empty word consisting of uppercase and lowercase latin letters.</p><h4 id="问题-10"><a href="#问题-10" class="headerlink" title="问题"></a>问题</h4><p>看string是否符合标准大写规则</p><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><p>分支判断</p><h4 id="C-12"><a href="#C-12" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">bool detectCapitalUse(string word) &#123;</span><br><span class="line">    char c = word[0];</span><br><span class="line">    if (!isupper(c)) &#123;</span><br><span class="line">        for (auto a:word) &#123;</span><br><span class="line">            if (isupper(a)) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        if (isupper(word[1])) &#123;</span><br><span class="line">            for (auto a:word) &#123;</span><br><span class="line">                if (islower(a)) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            for(int i = 2;i&lt;word.length();i++)&#123;</span><br><span class="line">                if (isupper(word[i])) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="别人写法-4"><a href="#别人写法-4" class="headerlink" title="别人写法"></a>别人写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public boolean detectCapitalUse(String word) &#123;</span><br><span class="line">       int cnt = 0;</span><br><span class="line">       for(char c: word.toCharArray()) if(&apos;Z&apos; - c &gt;= 0) cnt++;</span><br><span class="line">       return ((cnt==0 || cnt==word.length()) || (cnt==1 &amp;&amp; &apos;Z&apos; - word.charAt(0)&gt;=0));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="收获-7"><a href="#收获-7" class="headerlink" title="收获"></a>收获</h4><p>通过ASC码判断，大写字母的ASC码比小写字母小。</p><h3 id="104-Maximum-Depth-of-Binary-Tree"><a href="#104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104. Maximum Depth of Binary Tree"></a>104. Maximum Depth of Binary Tree</h3><h4 id="问题-11"><a href="#问题-11" class="headerlink" title="问题"></a>问题</h4><p>求树的最大深度</p><h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><p>深度优先||广度优先</p><h4 id="C-13"><a href="#C-13" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">深度优先</span><br><span class="line">int maxDepth(TreeNode* root) &#123;</span><br><span class="line">    return root == NULL ? 0 :max(maxDepth(root-&gt;left), maxDepth(root-&gt;right))+1;</span><br><span class="line">&#125;</span><br><span class="line">广度优先</span><br><span class="line">int maxDepth(TreeNode *root)</span><br><span class="line">&#123;</span><br><span class="line">    if(root == NULL)</span><br><span class="line">        return 0;</span><br><span class="line">    </span><br><span class="line">    int res = 0;</span><br><span class="line">    queue&lt;TreeNode *&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        ++ res;</span><br><span class="line">        for(int i = 0, n = q.size(); i &lt; n; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode *p = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            </span><br><span class="line">            if(p -&gt; left != NULL)</span><br><span class="line">                q.push(p -&gt; left);</span><br><span class="line">            if(p -&gt; right != NULL)</span><br><span class="line">                q.push(p -&gt; right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="389-Find-the-Difference"><a href="#389-Find-the-Difference" class="headerlink" title="389. Find the Difference"></a>389. Find the Difference</h3><h4 id="问题-12"><a href="#问题-12" class="headerlink" title="问题"></a>问题</h4><p>寻找两个字符串不同的字符</p><h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4><p>位运算 异或能找出单个不同的字符</p><h4 id="C-14"><a href="#C-14" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">char findTheDifference(string s, string t) &#123;</span><br><span class="line"></span><br><span class="line">    char res = &apos;\0&apos;;</span><br><span class="line">    for (char a:s) &#123;</span><br><span class="line">        res = res^a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (char b:t) &#123;</span><br><span class="line">        res = res^b;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res;</span><br><span class="line">    </span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获-8"><a href="#收获-8" class="headerlink" title="收获"></a>收获</h4><p>异或找不同</p><h3 id="371-Sum-of-Two-Integers"><a href="#371-Sum-of-Two-Integers" class="headerlink" title="371. Sum of Two Integers"></a>371. Sum of Two Integers</h3><p>Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.</p><h4 id="Example-5"><a href="#Example-5" class="headerlink" title="Example:"></a>Example:</h4><p>Given a = 1 and b = 2, return 3.</p><h4 id="问题-13"><a href="#问题-13" class="headerlink" title="问题"></a>问题</h4><p>在不使用+ -的情况下 实现加法</p><h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h4><p>通过异或来实现0+1或1+0，通过与并左移实现进位</p><h4 id="C-15"><a href="#C-15" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int getSum(int a, int b) &#123;</span><br><span class="line">    int sum = a;</span><br><span class="line">    while (b!=0) &#123;</span><br><span class="line">        sum = a^b;</span><br><span class="line">        b = (a&amp;b)&lt;&lt;1;</span><br><span class="line">        a = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获-9"><a href="#收获-9" class="headerlink" title="收获"></a>收获</h4><p>可以通过异或来实现0+1或1+0，通过与+左移实现进位</p><h3 id="226-Invert-Binary-Tree"><a href="#226-Invert-Binary-Tree" class="headerlink" title="226. Invert Binary Tree"></a>226. Invert Binary Tree</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Invert a binary tree.</span><br><span class="line"></span><br><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  2     7</span><br><span class="line"> / \   / \</span><br><span class="line">1   3 6   9</span><br><span class="line">to</span><br><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  7     2</span><br><span class="line"> / \   / \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure><h4 id="问题-14"><a href="#问题-14" class="headerlink" title="问题"></a>问题</h4><p>翻转二叉树</p><h4 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h4><p>递归，非递归（广度优先）</p><h4 id="C-16"><a href="#C-16" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">递归</span><br><span class="line">TreeNode* invertTree(TreeNode* root) &#123;</span><br><span class="line">              if(root == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (root) &#123;</span><br><span class="line">        TreeNode *temp = root-&gt;left;</span><br><span class="line">        root-&gt;left = root-&gt;right;</span><br><span class="line">        root-&gt;right = temp;</span><br><span class="line">        </span><br><span class="line">        if(root-&gt;left !=NULL)&#123;</span><br><span class="line">            invertTree(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        if (root-&gt;right !=NULL) &#123;</span><br><span class="line">            invertTree(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return root;</span><br><span class="line">    &#125;</span><br><span class="line">非递归</span><br><span class="line">TreeNode *invertTree(TreeNode *root)</span><br><span class="line">&#123;</span><br><span class="line">    stack&lt;TreeNode *&gt; stack;</span><br><span class="line">    stack.push(root);</span><br><span class="line">    while (!stack.empty()) &#123;</span><br><span class="line">        TreeNode *p = stack.top();</span><br><span class="line">        stack.pop();</span><br><span class="line">        if (p) &#123;</span><br><span class="line">            stack.push(root-&gt;left);</span><br><span class="line">            stack.push(root-&gt;right);</span><br><span class="line">            swap(root-&gt;left, root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获-10"><a href="#收获-10" class="headerlink" title="收获"></a>收获</h4><p>swap函数</p><h3 id="258-Add-Digits"><a href="#258-Add-Digits" class="headerlink" title="258. Add Digits"></a>258. Add Digits</h3><p>Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.</p><h4 id="For-example-1"><a href="#For-example-1" class="headerlink" title="For example:"></a>For example:</h4><p>Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.</p><h4 id="Follow-up-1"><a href="#Follow-up-1" class="headerlink" title="Follow up:"></a>Follow up:</h4><p>Could you do it without any loop/recursion in O(1) runtime?</p><h4 id="问题-15"><a href="#问题-15" class="headerlink" title="问题"></a>问题</h4><p>38-》3+8=11》1+1》2  一个数，各位数相加，直至只剩一位数</p><h4 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h4><p><a href="https://www.zhihu.com/question/30972581" target="_blank" rel="noopener">数根</a></p><h4 id="C-17"><a href="#C-17" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int addDigits(int num) &#123;</span><br><span class="line">    return 1+(num-1)%9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获-11"><a href="#收获-11" class="headerlink" title="收获"></a>收获</h4><p>12345 % 9 = (1 + 2 + 3 + 4 +5 ) % 9 </p><h3 id="492-Construct-the-Rectangle"><a href="#492-Construct-the-Rectangle" class="headerlink" title="492. Construct the Rectangle"></a>492. Construct the Rectangle</h3><p>For a web developer, it is very important to know how to design a web page’s size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. The area of the rectangular web page you designed must equal to the given target area.</span><br><span class="line"></span><br><span class="line">2. The width W should not be larger than the length L, which means L &gt;= W.</span><br><span class="line"></span><br><span class="line">3. The difference between length L and width W should be as small as possible.</span><br><span class="line">You need to output the length L and the width W of the web page you designed in sequence.</span><br></pre></td></tr></table></figure><h4 id="Example-6"><a href="#Example-6" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: [2, 2]</span><br><span class="line">Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. </span><br><span class="line">But according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.</span><br></pre></td></tr></table></figure><h4 id="Note-7"><a href="#Note-7" class="headerlink" title="Note:"></a>Note:</h4><p>The given area won’t exceed 10,000,000 and is a positive integer<br>The web page’s width and length you designed must be positive integers</p><h4 id="问题-16"><a href="#问题-16" class="headerlink" title="问题"></a>问题</h4><p>给定一个正方形面积，求出符合要求的一组长款</p><h4 id="收获-12"><a href="#收获-12" class="headerlink" title="收获"></a>收获</h4><p>时间复杂度，的优化</p><h4 id="C-18"><a href="#C-18" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">写法1：99ms</span><br><span class="line">vector&lt;int&gt; constructRectangle(int area) &#123;</span><br><span class="line">    </span><br><span class="line">    int l = sqrt(area);</span><br><span class="line">    for(int i = l;i&lt;=area;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (area%i==0) &#123;</span><br><span class="line">            l=i;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int w = area/l;</span><br><span class="line">    </span><br><span class="line">    if(w&gt;l)&#123;</span><br><span class="line">        swap(w,l);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; result = &#123;l,w&#125;;</span><br><span class="line">    </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">更新写法2：3ms</span><br><span class="line">vector&lt;int&gt; constructRectangle(int area) &#123;</span><br><span class="line">    </span><br><span class="line">    int w ;</span><br><span class="line">    for(int i = 1;i*i&lt;=area;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (area%i==0) &#123;</span><br><span class="line">            w=i;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; result = &#123;area/w,w&#125;;</span><br><span class="line">    </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获-13"><a href="#收获-13" class="headerlink" title="收获"></a>收获</h4><p>不用系统函数，想办法替代</p><h3 id="283-Move-Zeroes"><a href="#283-Move-Zeroes" class="headerlink" title="283. Move Zeroes"></a>283. Move Zeroes</h3><p>Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p><p>For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].</p><h4 id="Note-8"><a href="#Note-8" class="headerlink" title="Note:"></a>Note:</h4><p>You must do this in-place without making a copy of the array.<br>Minimize the total number of operations.</p><h4 id="问题-17"><a href="#问题-17" class="headerlink" title="问题"></a>问题</h4><p>将数组中的0移动到数组末尾</p><h4 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h4><p>遇到非0就覆盖原数组，最后再将0添上</p><h4 id="C-19"><a href="#C-19" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int j = 0;</span><br><span class="line">    for (int i=0; i&lt;nums.size(); i++) &#123;</span><br><span class="line">        if (nums[i]!=0) &#123;</span><br><span class="line">            nums[j++]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (; j&lt;nums.size(); j++) &#123;</span><br><span class="line">        nums[j] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="506-Relative-Ranks"><a href="#506-Relative-Ranks" class="headerlink" title="506. Relative Ranks"></a>506. Relative Ranks</h3><p>Given scores of N athletes, find their relative ranks and the people with the top three highest scores, who will be awarded medals: “Gold Medal”, “Silver Medal” and “Bronze Medal”.</p><h4 id="Example-1-5"><a href="#Example-1-5" class="headerlink" title="Example 1:"></a>Example 1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [5, 4, 3, 2, 1]</span><br><span class="line">Output: [&quot;Gold Medal&quot;, &quot;Silver Medal&quot;, &quot;Bronze Medal&quot;, &quot;4&quot;, &quot;5&quot;]</span><br><span class="line">Explanation: The first three athletes got the top three highest scores, so they got &quot;Gold Medal&quot;, &quot;Silver Medal&quot; and &quot;Bronze Medal&quot;. </span><br><span class="line">For the left two athletes, you just need to output their relative ranks according to their scores.</span><br></pre></td></tr></table></figure><h4 id="Note-9"><a href="#Note-9" class="headerlink" title="Note:"></a>Note:</h4><p>N is a positive integer and won’t exceed 10,000.<br>All the scores of athletes are guaranteed to be unique.</p><h4 id="问题-18"><a href="#问题-18" class="headerlink" title="问题"></a>问题</h4><p>根据数组中的得，输出其对应的排名    </p><h4 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a>思路</h4><p>利用C++ map的递增特性，进行输出</p><h4 id="C-20"><a href="#C-20" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; findRelativeRanks(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line"></span><br><span class="line">    map&lt;int,int&gt; mp;</span><br><span class="line">    </span><br><span class="line">    for (int i=0; i&lt;nums.size(); i++) &#123;</span><br><span class="line">        mp[nums[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;string&gt; res(nums.size(),&quot;&quot;);</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    for (map&lt;int,int&gt;::reverse_iterator it = mp.rbegin(); it!=mp.rend(); it++,cnt++) &#123;</span><br><span class="line">        if (cnt== 0) &#123;</span><br><span class="line">            res[it-&gt;second] = &quot;Gold Medal&quot;;</span><br><span class="line">        &#125;else if (cnt==1)&#123;</span><br><span class="line">            res[it-&gt;second] = &quot;Silver Medal&quot;;</span><br><span class="line">        &#125;else if (cnt==2)&#123;</span><br><span class="line">            res[it-&gt;second] = &quot;Bronze Medal&quot;;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            res[it-&gt;second] = to_string(cnt+1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获-14"><a href="#收获-14" class="headerlink" title="收获"></a>收获</h4><p>C++ map是递增的，it—&gt;first是key it-&gt;second是value，倒序遍历迭代器的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(map&lt;int,int&gt;::reverse_iterator it=mp.rbegin();it!+mp.rend();it++)</span><br></pre></td></tr></table></figure><h3 id="530-Minimum-Absolute-Difference-in-BST"><a href="#530-Minimum-Absolute-Difference-in-BST" class="headerlink" title="530. Minimum Absolute Difference in BST"></a>530. Minimum Absolute Difference in BST</h3><p>Given a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.</p><h4 id="Example-7"><a href="#Example-7" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     3</span><br><span class="line">    /</span><br><span class="line">   2</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h4 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation:"></a>Explanation:</h4><p>The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).<br>Note: There are at least two nodes in this BST.</p><h4 id="问题-19"><a href="#问题-19" class="headerlink" title="问题"></a>问题</h4><p>求二叉搜索树中，求两个结点绝对值相差最小的值</p><h4 id="思路-18"><a href="#思路-18" class="headerlink" title="思路"></a>思路</h4><p>中序遍历出的二叉搜索树是有序递增的，在这个有序的队列中求最小值</p><h4 id="C-21"><a href="#C-21" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> public:void inorderTraverse(TreeNode* root, int&amp; val, int&amp; min_dif) &#123;</span><br><span class="line">    if (root-&gt;left != NULL) inorderTraverse(root-&gt;left, val, min_dif);</span><br><span class="line">    if (val &gt;= 0) min_dif = min(min_dif, root-&gt;val - val);</span><br><span class="line">    val = root-&gt;val;</span><br><span class="line">    if (root-&gt;right != NULL) inorderTraverse(root-&gt;right, val, min_dif);</span><br><span class="line">&#125;</span><br><span class="line">public:int getMinimumDifference(TreeNode* root) &#123;</span><br><span class="line">    auto min_dif = INT_MAX, val = -1;</span><br><span class="line">    inorderTraverse(root, val, min_dif);</span><br><span class="line">    return min_dif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获-15"><a href="#收获-15" class="headerlink" title="收获"></a>收获</h4><p>中序遍历二叉搜索树是有序的</p><h3 id="167-Two-Sum-II-Input-array-is-sorted"><a href="#167-Two-Sum-II-Input-array-is-sorted" class="headerlink" title="167. Two Sum II - Input array is sorted"></a>167. Two Sum II - Input array is sorted</h3><p>Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.</p><p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p><p>You may assume that each input would have exactly one solution and you may not use the same element twice.</p><h4 id="Input"><a href="#Input" class="headerlink" title="Input:"></a>Input:</h4><p>numbers={2, 7, 11, 15}, target=9</p><h4 id="Output"><a href="#Output" class="headerlink" title="Output:"></a>Output:</h4><p>index1=1, index2=2</p><h4 id="问题-20"><a href="#问题-20" class="headerlink" title="问题"></a>问题</h4><p>给一个数组，给一个目标，找出相加为目标数的两个数在数组中的位置</p><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>一左一右两个指针， while</p><h4 id="C-22"><a href="#C-22" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;</span><br><span class="line">    </span><br><span class="line">    int r = (int)numbers.size() - 1;</span><br><span class="line">    </span><br><span class="line">    int l = 0;</span><br><span class="line">    </span><br><span class="line">    while (l&lt;r) &#123;</span><br><span class="line">        if (numbers[l] + numbers[r] == target) &#123;</span><br><span class="line">          vector&lt;int&gt; res&#123;l+1,r+1&#125;;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;else if(numbers[l] + numbers[r] &gt; target)&#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;else if(numbers[l] + numbers[r] &lt; target)&#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; fail;</span><br><span class="line">    return fail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="521-Longest-Uncommon-Subsequence-I"><a href="#521-Longest-Uncommon-Subsequence-I" class="headerlink" title="521. Longest Uncommon Subsequence I"></a>521. Longest Uncommon Subsequence I</h3><p>Given a group of two strings, you need to find the longest uncommon subsequence of this group of two strings. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings.</p><p>A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.</p><p>The input will be two strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn’t exist, return -1.</p><h4 id="Example-1-6"><a href="#Example-1-6" class="headerlink" title="Example 1:"></a>Example 1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;aba&quot;, &quot;cdc&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The longest uncommon subsequence is &quot;aba&quot; (or &quot;cdc&quot;), </span><br><span class="line">because &quot;aba&quot; is a subsequence of &quot;aba&quot;, </span><br><span class="line">but not a subsequence of any other strings in the group of two strings.</span><br></pre></td></tr></table></figure><h4 id="Note-10"><a href="#Note-10" class="headerlink" title="Note:"></a>Note:</h4><p>Both strings’ lengths will not exceed 100.<br>Only letters from a ~ z will appear in input strings.</p><h4 id="问题-21"><a href="#问题-21" class="headerlink" title="问题"></a>问题</h4><p>两个字符串中最长的字符串是否是第二个字符串的子串，如果是则返回-1，否做返回其长度</p><h4 id="C-23"><a href="#C-23" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int findLUSlength(string a, string b) &#123;</span><br><span class="line">    </span><br><span class="line">    if (a.size() == b.size()) &#123;</span><br><span class="line">        if (a==b) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return (int)a.size();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return (int)max(a.size(), b.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="455-Assign-Cookies"><a href="#455-Assign-Cookies" class="headerlink" title="455. Assign Cookies"></a>455. Assign Cookies</h3><p>Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj &gt;= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.</p><h4 id="Note-11"><a href="#Note-11" class="headerlink" title="Note:"></a>Note:</h4><p>You may assume the greed factor is always positive.<br>You cannot assign more than one cookie to one child.</p><h4 id="Example-1-7"><a href="#Example-1-7" class="headerlink" title="Example 1:"></a>Example 1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3], [1,1]</span><br><span class="line"></span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. </span><br><span class="line">And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.</span><br><span class="line">You need to output 1.</span><br></pre></td></tr></table></figure><h4 id="Example-2-3"><a href="#Example-2-3" class="headerlink" title="Example 2:"></a>Example 2:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2], [1,2,3]</span><br><span class="line"></span><br><span class="line">Output: 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. </span><br><span class="line">You have 3 cookies and their sizes are big enough to gratify all of the children, </span><br><span class="line">You need to output 2.</span><br></pre></td></tr></table></figure><h4 id="问题-22"><a href="#问题-22" class="headerlink" title="问题"></a>问题</h4><p>给小孩分曲奇，两个数组<br>第一个是小孩的需求数组【1，2，3】，代表有3个小孩，分别要1，2，3大小的曲奇<br>第二个是自己拥有的曲奇数组【1，2】代表有2个曲奇，大小分别为1，2</p><h4 id="思路-19"><a href="#思路-19" class="headerlink" title="思路"></a>思路</h4><p>贪心算法，先对两个数组进行递增排序，随后开始比较，作一个关于饼干数组的循环，如果遇到合适的小孩，则分配给他，然后对下一个下小孩进行分析</p><h4 id="C-24"><a href="#C-24" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123;</span><br><span class="line">    sort(g.begin(),g.end());</span><br><span class="line">    sort(s.begin(), s.end());</span><br><span class="line">    </span><br><span class="line">    int i=0,j=0;</span><br><span class="line">    </span><br><span class="line">    for (; i &lt; g.size()&amp;&amp; j &lt; s.size(); j++) &#123;</span><br><span class="line">        if (g[i]&lt;=s[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="收获-16"><a href="#收获-16" class="headerlink" title="收获"></a>收获</h4><p>贪心算法，sort函数</p><h3 id="453-Minimum-Moves-to-Equal-Array-Elements"><a href="#453-Minimum-Moves-to-Equal-Array-Elements" class="headerlink" title="453. Minimum Moves to Equal Array Elements"></a>453. Minimum Moves to Equal Array Elements</h3><p>Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1.</p><h4 id="Example-8"><a href="#Example-8" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[1,2,3]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h4 id="Explanation-1"><a href="#Explanation-1" class="headerlink" title="Explanation:"></a>Explanation:</h4><p>Only three moves are needed (remember each move increments two elements):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3]  =&gt;  [2,3,3]  =&gt;  [3,4,3]  =&gt;  [4,4,4]</span><br></pre></td></tr></table></figure><h4 id="问题-23"><a href="#问题-23" class="headerlink" title="问题"></a>问题</h4><p>给一组n个数，每次只能进行n-1个数的+1操作，问将他们都变为相同的数字最少需要几步。</p><h4 id="思路-20"><a href="#思路-20" class="headerlink" title="思路"></a>思路</h4><p>（min+k）<em>n = sum+k</em>(n-1)<br>k = sum - min*n</p><h4 id="C-25"><a href="#C-25" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int minMoves(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    </span><br><span class="line">    if (nums.size()&lt;=1) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        int sum=0,minimum=INT_MAX;</span><br><span class="line">        for (int i=0; i&lt;nums.size(); i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            minimum = min(minimum,nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        int res = sum-(int)(minimum*nums.size());</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="别人写法-5"><a href="#别人写法-5" class="headerlink" title="别人写法"></a>别人写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int minMoves(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    return accumulate(begin(nums), end(nums), 0L) - nums.size() * *min_element(begin(nums), end(nums));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获-17"><a href="#收获-17" class="headerlink" title="收获"></a>收获</h4><p>列出等式，找规律 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;numeric&gt;</span><br><span class="line">int sum = accumulate(begin(nums), end(nums), 0);</span><br><span class="line">min_element(begin(nums), end(nums));</span><br></pre></td></tr></table></figure><h3 id="383-Ransom-Note"><a href="#383-Ransom-Note" class="headerlink" title="383. Ransom Note"></a>383. Ransom Note</h3><p>Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false.</p><p>Each letter in the magazine string can only be used once in your ransom note.</p><h4 id="Note-12"><a href="#Note-12" class="headerlink" title="Note:"></a>Note:</h4><p>You may assume that both strings contain only lowercase letters.</p><p>canConstruct(“a”, “b”) -&gt; false<br>canConstruct(“aa”, “ab”) -&gt; false<br>canConstruct(“aa”, “aab”) -&gt; true</p><h4 id="问题-24"><a href="#问题-24" class="headerlink" title="问题"></a>问题</h4><p>给两个数组，如果能用第二个数组中的元素构成第一个数组，则返回true</p><h4 id="思路-21"><a href="#思路-21" class="headerlink" title="思路"></a>思路</h4><p>对数组2的每一个字母进行计数+1，计数完后再对数组1对应进行计数-1，如果有数计数&lt;0，则返回false，否则则返回true</p><h4 id="C-26"><a href="#C-26" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bool canConstruct(string ransomNote, string magazine) &#123;</span><br><span class="line">    vector&lt;int&gt; vec(26,0);</span><br><span class="line">    </span><br><span class="line">    for (int i=0; i&lt;magazine.size(); i++) &#123;</span><br><span class="line">        ++vec[magazine[i]-&apos;a&apos;];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int j=0; j&lt;ransomNote.size(); j++) &#123;</span><br><span class="line">        if (--vec[ransomNote[j]-&apos;a&apos;]&lt;0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获-18"><a href="#收获-18" class="headerlink" title="收获"></a>收获</h4><p>一种比较的思路</p><h3 id="349-Intersection-of-Two-Arrays"><a href="#349-Intersection-of-Two-Arrays" class="headerlink" title="349. Intersection of Two Arrays"></a>349. Intersection of Two Arrays</h3><p>Given two arrays, write a function to compute their intersection.</p><h4 id="Example-9"><a href="#Example-9" class="headerlink" title="Example:"></a>Example:</h4><p>Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].</p><h4 id="Note-13"><a href="#Note-13" class="headerlink" title="Note:"></a>Note:</h4><p>Each element in the result must be unique.<br>The result can be in any order.<br>Subscribe to see which companies asked this question.</p><h4 id="问题-25"><a href="#问题-25" class="headerlink" title="问题"></a>问题</h4><p>给2个数组，找出共同的元素</p><h4 id="思路-22"><a href="#思路-22" class="headerlink" title="思路"></a>思路</h4><p>比较，去除重复元素 使用unique</p><h4 id="C-27"><a href="#C-27" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">    if(nums1.size()&lt;=0||nums2.size()&lt;=0)</span><br><span class="line">    &#123;</span><br><span class="line">        return vector&lt;int&gt;&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    sort(nums1.begin(),nums1.end());</span><br><span class="line">    sort(nums2.begin(),nums2.end());</span><br><span class="line">    int i=0,j=0;</span><br><span class="line">    for (; i&lt;nums1.size()&amp;&amp;j&lt;nums2.size(); j++) &#123;</span><br><span class="line">        if (nums1[i]==nums2[j]) &#123;</span><br><span class="line">            res.push_back(nums1[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;else if (nums1[i]&lt;nums2[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt;::iterator new_end;</span><br><span class="line">    new_end=unique(res.begin(),res.end());</span><br><span class="line">    res.erase(new_end, res.end());</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获-19"><a href="#收获-19" class="headerlink" title="收获"></a>收获</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">去除重复元素</span><br><span class="line"></span><br><span class="line">new_end=unique(res.begin(),res.end());</span><br><span class="line">res.erase(new_end, res.end());</span><br></pre></td></tr></table></figure><h3 id="404-Sum-of-Left-Leaves"><a href="#404-Sum-of-Left-Leaves" class="headerlink" title="404. Sum of Left Leaves"></a>404. Sum of Left Leaves</h3><p>Find the sum of all left leaves in a given binary tree.</p><h4 id="Example-10"><a href="#Example-10" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.</p><h4 id="问题-26"><a href="#问题-26" class="headerlink" title="问题"></a>问题</h4><p>统计一棵树的左叶子和</p><h4 id="思路-23"><a href="#思路-23" class="headerlink" title="思路"></a>思路</h4><p>递归</p><h4 id="C-28"><a href="#C-28" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int sumOfLeftLeaves(TreeNode* root) &#123;</span><br><span class="line">    </span><br><span class="line">    if(!root)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    if (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) &#123;</span><br><span class="line">        return root-&gt;left-&gt;val + sumOfLeftLeaves(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return sumOfLeftLeaves(root-&gt;left) + sumOfLeftLeaves(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获-20"><a href="#收获-20" class="headerlink" title="收获"></a>收获</h4><p>从最小的一部分观察，制定递归策略</p><h3 id="122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122. Best Time to Buy and Sell Stock II"></a>122. Best Time to Buy and Sell Stock II</h3><p>Say you have an array for which the ith element is the price of a given stock on day i.</p><p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p><h4 id="问题-27"><a href="#问题-27" class="headerlink" title="问题"></a>问题</h4><p>给一个数组，数组i代表天数，a[i-1]代表当天股票价值，问怎么样才能获取最大值？</p><h4 id="思路-24"><a href="#思路-24" class="headerlink" title="思路"></a>思路</h4><p>累加差值，如果遇到下跌的天数就跳过</p><h4 id="C-29"><a href="#C-29" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int maxProfit(vector&lt;int&gt; &amp;prices)</span><br><span class="line">&#123;</span><br><span class="line">    if (prices.size() == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int maximum = 0;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; prices.size()-1; i++) &#123;</span><br><span class="line">       </span><br><span class="line">        if (prices[i] &lt; prices[i+1]) &#123;</span><br><span class="line">            maximum = maximum + prices[i+1]-prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return maximum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="别人的写法"><a href="#别人的写法" class="headerlink" title="别人的写法"></a>别人的写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int maxProfit(vector&lt;int&gt; &amp;prices) &#123;</span><br><span class="line">    int ret = 0;</span><br><span class="line">    for (size_t p = 1; p &lt; prices.size(); ++p) </span><br><span class="line">      ret += max(prices[p] - prices[p - 1], 0);    </span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获-21"><a href="#收获-21" class="headerlink" title="收获"></a>收获</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (prices[i] &lt; prices[i+1]) </span><br><span class="line">&#123;</span><br><span class="line">     maximum = maximum + prices[i+1]-prices[i];</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"> ret += max(prices[p] - prices[p - 1], 0);</span><br></pre></td></tr></table></figure><h3 id="387-First-Unique-Character-in-a-String"><a href="#387-First-Unique-Character-in-a-String" class="headerlink" title="387. First Unique Character in a String"></a>387. First Unique Character in a String</h3><p>Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1.</p><h4 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;leetcode&quot;</span><br><span class="line">return 0.</span><br><span class="line"></span><br><span class="line">s = &quot;loveleetcode&quot;,</span><br><span class="line">return 2.</span><br></pre></td></tr></table></figure><h4 id="问题-28"><a href="#问题-28" class="headerlink" title="问题"></a>问题</h4><p>求string中第一个不重复的字符的下标</p><h4 id="思路-25"><a href="#思路-25" class="headerlink" title="思路"></a>思路</h4><p>使用map将string按字符一个个存入map，并count</p><h4 id="C-30"><a href="#C-30" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int firstUniqChar(string s) &#123;</span><br><span class="line">    unordered_map&lt;char, int&gt; map;</span><br><span class="line">    </span><br><span class="line">    for(auto c:s)</span><br><span class="line">    &#123;</span><br><span class="line">        map[c]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i&lt; s.size(); i++) &#123;</span><br><span class="line">        if(map[s[i]] - 1 ==0)</span><br><span class="line">        &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获-22"><a href="#收获-22" class="headerlink" title="收获"></a>收获</h4><p>多用键值对，通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i&lt; s.size(); i++) &#123;</span><br><span class="line">        if(map[s[i]] - 1 ==0)</span><br><span class="line">        &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>能实现按顺序查找第一个不重复的字符。</p><h3 id="122-Best-Time-to-Buy-and-Sell-Stock-II-1"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II-1" class="headerlink" title="122. Best Time to Buy and Sell Stock II"></a>122. Best Time to Buy and Sell Stock II</h3><p>Say you have an array for which the ith element is the price of a given stock on day i.</p><p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p><h4 id="问题-29"><a href="#问题-29" class="headerlink" title="问题"></a>问题</h4><p>给定一个数组 下标为天数，各个元素为当天股票价格，球可获利的最大值</p><h4 id="思路-26"><a href="#思路-26" class="headerlink" title="思路"></a>思路</h4><p>累加</p><h4 id="C-31"><a href="#C-31" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int maxProfit(vector&lt;int&gt; &amp;prices) &#123;</span><br><span class="line">    int ret = 0;</span><br><span class="line">    for (size_t p = 1; p &lt; prices.size(); ++p) </span><br><span class="line">      ret += max(prices[p] - prices[p - 1], 0);    </span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="171-Excel-Sheet-Column-Number"><a href="#171-Excel-Sheet-Column-Number" class="headerlink" title="171. Excel Sheet Column Number"></a>171. Excel Sheet Column Number</h3><p>Given a column title as appear in an Excel sheet, return its corresponding column number.</p><h4 id="For-example-2"><a href="#For-example-2" class="headerlink" title="For example:"></a>For example:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; 1</span><br><span class="line">B -&gt; 2</span><br><span class="line">C -&gt; 3</span><br><span class="line">...</span><br><span class="line">Z -&gt; 26</span><br><span class="line">AA -&gt; 27</span><br><span class="line">AB -&gt; 28</span><br></pre></td></tr></table></figure><h4 id="问题-30"><a href="#问题-30" class="headerlink" title="问题"></a>问题</h4><p>类似于Excel的列标题，求其代表的数字</p><h4 id="思路-27"><a href="#思路-27" class="headerlink" title="思路"></a>思路</h4><p>按位数分析累加</p><h4 id="C-32"><a href="#C-32" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int titleToNumber(string s) &#123;</span><br><span class="line">    </span><br><span class="line">    int res = 0;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; s.size(); res = res*26 + s[i] - &apos;A&apos; + 1 , i++ ) ;</span><br><span class="line">    </span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="237-Delete-Node-in-a-Linked-Lis"><a href="#237-Delete-Node-in-a-Linked-Lis" class="headerlink" title="237. Delete Node in a Linked Lis"></a>237. Delete Node in a Linked Lis</h3><p>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.</p><p>Supposed the linked list is 1 -&gt; 2 -&gt; 3 -&gt; 4 and you are given the third node with value 3, the linked list should become 1 -&gt; 2 -&gt; 4 after calling your function.</p><h4 id="问题-31"><a href="#问题-31" class="headerlink" title="问题"></a>问题</h4><p>删除节点</p><h4 id="思路-28"><a href="#思路-28" class="headerlink" title="思路"></a>思路</h4><p>用被删除结点之后的结点替换被删除结点</p><h4 id="C-33"><a href="#C-33" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void deleteNode(ListNode* node) &#123;</span><br><span class="line">    *node = *node -&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="100-Same-Tree"><a href="#100-Same-Tree" class="headerlink" title="100. Same Tree"></a>100. Same Tree</h3><p>Given two binary trees, write a function to check if they are equal or not.</p><p>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.</p><h4 id="问题-32"><a href="#问题-32" class="headerlink" title="问题"></a>问题</h4><p>判断两棵树是否相等</p><h4 id="思路-29"><a href="#思路-29" class="headerlink" title="思路"></a>思路</h4><p>递归判断</p><h4 id="C-34"><a href="#C-34" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bool isSameTree(TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">    </span><br><span class="line">    if (p == NULL || q == NULL) &#123;</span><br><span class="line">        return p==q;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return (p-&gt;val == q-&gt;val &amp;&amp; isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="169-Majority-Element"><a href="#169-Majority-Element" class="headerlink" title="169. Majority Element"></a>169. Majority Element</h3><p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p><p>You may assume that the array is non-empty and the majority element always exist in the array</p><h4 id="问题-33"><a href="#问题-33" class="headerlink" title="问题"></a>问题</h4><p>求一个数组中，出现次数超过一半的字符</p><h4 id="思路-30"><a href="#思路-30" class="headerlink" title="思路"></a>思路</h4><p>排序后，出现次数超过一半的字符肯定在中间</p><h4 id="C-35"><a href="#C-35" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">int majorityElement(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    </span><br><span class="line">    unordered_map&lt;int, int&gt; cnt;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        cnt[nums[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i=0; i&lt;nums.size(); i++) &#123;</span><br><span class="line">        if(cnt[nums[i]] &gt; nums.size()/2)&#123;</span><br><span class="line">            return nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="别人的写法-1"><a href="#别人的写法-1" class="headerlink" title="别人的写法"></a>别人的写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int majorityElement(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    nth_element(nums.begin(), nums.begin() + nums.size() / 2, nums.end());</span><br><span class="line">    return nums[nums.size() / 2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="242-Valid-Anagram"><a href="#242-Valid-Anagram" class="headerlink" title="242. Valid Anagram"></a>242. Valid Anagram</h3><p>Given two strings s and t, write a function to determine if t is an anagram of s.</p><h4 id="For-example-3"><a href="#For-example-3" class="headerlink" title="For example,"></a>For example,</h4><p>s = “anagram”, t = “nagaram”, return true.<br>s = “rat”, t = “car”, return false.</p><h4 id="Note-14"><a href="#Note-14" class="headerlink" title="Note:"></a>Note:</h4><p>You may assume the string contains only lowercase alphabets.</p><h4 id="Follow-up-2"><a href="#Follow-up-2" class="headerlink" title="Follow up:"></a>Follow up:</h4><p>What if the inputs contain unicode characters? How would you adapt your solution to such case?</p><h4 id="问题-34"><a href="#问题-34" class="headerlink" title="问题"></a>问题</h4><p>两个数组，问他们是否重新组合后是否为同一个单词</p><h4 id="思路-31"><a href="#思路-31" class="headerlink" title="思路"></a>思路</h4><p>对第二个数组中的字母一一计数，随后再对第一个数组中的字母一一扣除，如果为负，则false</p><h4 id="C-36"><a href="#C-36" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">bool isAnagram(string s, string t) &#123;</span><br><span class="line">    vector&lt;int&gt; count(26,0);</span><br><span class="line">    </span><br><span class="line">       if (s.size() != t.size()) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i=0; i&lt;s.size(); i++) &#123;</span><br><span class="line">        ++count[s[i]-&apos;a&apos;];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int j=0; j&lt;t.size(); j++) &#123;</span><br><span class="line">        if (--count[t[j]-&apos;a&apos;]&lt;0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return true;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="504-Base-7"><a href="#504-Base-7" class="headerlink" title="504. Base 7"></a>504. Base 7</h3><p>Given an integer, return its base 7 string representation.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: 100</span><br><span class="line">Output: &quot;202&quot;</span><br><span class="line">Example 2:</span><br><span class="line">Input: -7</span><br><span class="line">Output: &quot;-10&quot;</span><br><span class="line">Note: The input will be in range of [-1e7, 1e7].</span><br></pre></td></tr></table></figure><h4 id="问题-35"><a href="#问题-35" class="headerlink" title="问题"></a>问题</h4><p>给一个数，转化为7进制数</p><h4 id="思路-32"><a href="#思路-32" class="headerlink" title="思路"></a>思路</h4><p>递除取余</p><h4 id="C-37"><a href="#C-37" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">string convertToBase7(int num) &#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int n = num;</span><br><span class="line">    string res = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    num = abs(num);</span><br><span class="line">    do &#123;</span><br><span class="line">        res.insert(i,to_string(num%7));</span><br><span class="line">        num = num/7;</span><br><span class="line">    &#125; while (num != 0);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    return (n &gt;=0?&quot;&quot;:&quot;-&quot;) + res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="409-Longest-Palindrome"><a href="#409-Longest-Palindrome" class="headerlink" title="409. Longest Palindrome"></a>409. Longest Palindrome</h3><p>Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.</p><p>This is case sensitive, for example “Aa” is not considered a palindrome here.</p><h4 id="Note-15"><a href="#Note-15" class="headerlink" title="Note:"></a>Note:</h4><p>Assume the length of given string will not exceed 1,010.</p><h4 id="Example-11"><a href="#Example-11" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;abccccdd&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">One longest palindrome that can be built is &quot;dccaccd&quot;, whose length is 7.</span><br></pre></td></tr></table></figure><h4 id="问题-36"><a href="#问题-36" class="headerlink" title="问题"></a>问题</h4><p>求能组成的最长回文子串的长度</p><h4 id="思路-33"><a href="#思路-33" class="headerlink" title="思路"></a>思路</h4><p>统计所有偶数长度的字符并相加，统计所有奇数长度的字符并减一相加，只保留一个奇数不减一</p><h4 id="C-38"><a href="#C-38" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int longestPalindrome(string s) &#123;</span><br><span class="line">    vector&lt;int&gt; m(256,0);</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    for (auto i : s) &#123;</span><br><span class="line">        m[i-&apos;\0&apos;]++;</span><br><span class="line">    &#125;</span><br><span class="line">    for (auto j : m) &#123;</span><br><span class="line">        cnt += j % 2 ? (cnt % 2 ? j-1 : j) :  j;</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="217-Contains-Duplicate"><a href="#217-Contains-Duplicate" class="headerlink" title="217. Contains Duplicate"></a>217. Contains Duplicate</h3><p>Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p><h4 id="问题-37"><a href="#问题-37" class="headerlink" title="问题"></a>问题</h4><p>给一个数字数组，如果有重复的则返回true</p><h4 id="思路-34"><a href="#思路-34" class="headerlink" title="思路"></a>思路</h4><p>统计，遇到超过1的返回</p><h4 id="C-39"><a href="#C-39" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    unordered_map&lt;int, int&gt; map;</span><br><span class="line">    </span><br><span class="line">    if (nums.size()==0) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i: nums) &#123;</span><br><span class="line">        if(++map[i]&gt;1)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-Roman-to-Integer"><a href="#13-Roman-to-Integer" class="headerlink" title="13. Roman to Integer"></a>13. Roman to Integer</h3><p>Given a roman numeral, convert it to an integer.</p><p>Input is guaranteed to be within the range from 1 to 3999.</p><h4 id="问题-38"><a href="#问题-38" class="headerlink" title="问题"></a>问题</h4><p>转化罗马数字</p><h4 id="思路-35"><a href="#思路-35" class="headerlink" title="思路"></a>思路</h4><p>做一个字典，分小紧随大，大紧随小 两种罗马字符减加情况</p><h4 id="C-40"><a href="#C-40" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">    int romanToInt(string s)</span><br><span class="line">&#123;</span><br><span class="line">    unordered_map&lt;char, int&gt; map&#123;&#123;&apos;I&apos;, 1&#125;,</span><br><span class="line">                                 &#123;&apos;V&apos;, 5&#125;,</span><br><span class="line">                                 &#123;&apos;X&apos;, 10&#125;,</span><br><span class="line">                                 &#123;&apos;L&apos;, 50&#125;,</span><br><span class="line">                                 &#123;&apos;C&apos;, 100&#125;,</span><br><span class="line">                                 &#123;&apos;D&apos;, 500&#125;,</span><br><span class="line">                                 &#123;&apos;M&apos;, 1000&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    int res = 0;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; s.size(); i++) &#123;</span><br><span class="line">        if (map[s[i]]&lt;map[s[i+1]]) &#123;</span><br><span class="line">            res -= map[s[i]];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            res += map[s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="401-Binary-Watch"><a href="#401-Binary-Watch" class="headerlink" title="401. Binary Watch"></a>401. Binary Watch</h3><p>A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59).</p><p>Each LED represents a zero or one, with the least significant bit on the right.</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/8/8b/Binary_clock_samui_moon.jpg" alt="image"><br>For example, the above binary watch reads “3:25”.</p><p>Given a non-negative integer n which represents the number of LEDs that are currently on, return all possible times the watch could represent.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 1</span><br><span class="line">Return: [&quot;1:00&quot;, &quot;2:00&quot;, &quot;4:00&quot;, &quot;8:00&quot;, &quot;0:01&quot;, &quot;0:02&quot;, &quot;0:04&quot;, &quot;0:08&quot;, &quot;0:16&quot;, &quot;0:32&quot;]</span><br><span class="line">Note:</span><br><span class="line">The order of output does not matter.</span><br><span class="line">The hour must not contain a leading zero, for example &quot;01:00&quot; is not valid, it should be &quot;1:00&quot;.</span><br><span class="line">The minute must be consist of two digits and may contain a leading zero, for example &quot;10:2&quot; is not valid, it should be &quot;10:02&quot;.</span><br></pre></td></tr></table></figure><h4 id="问题-39"><a href="#问题-39" class="headerlink" title="问题"></a>问题</h4><p>二进制手表，当亮点个数为n时，给出所有时间组合</p><h4 id="思路-36"><a href="#思路-36" class="headerlink" title="思路"></a>思路</h4><p>二进制表示各时间，符合count则添加进返回vector</p><h4 id="C-41"><a href="#C-41" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; readBinaryWatch(int num) &#123;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    for(int h = 0; h &lt; 12;h++)</span><br><span class="line">        for(int m = 0; m &lt; 60;m++)&#123;</span><br><span class="line">            if (bitset&lt;10&gt;(h&lt;&lt;6|m).count() == num) &#123;</span><br><span class="line">                res.emplace_back(to_string(h) + (m&lt;10?&quot;:0&quot;:&quot;:&quot;)  + to_string(m));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获-23"><a href="#收获-23" class="headerlink" title="收获"></a>收获</h4><p>bitset<10></10></p><p>emplace_back 比 push_back 更高效</p><h3 id="206-Reverse-Linked-List"><a href="#206-Reverse-Linked-List" class="headerlink" title="206. Reverse Linked List"></a>206. Reverse Linked List</h3><h4 id="问题-40"><a href="#问题-40" class="headerlink" title="问题"></a>问题</h4><p>翻转链表</p><h4 id="思路-37"><a href="#思路-37" class="headerlink" title="思路"></a>思路</h4><p>设立一个pre指针，一个next指针，进行翻转</p><h4 id="C-42"><a href="#C-42" class="headerlink" title="C++"></a>C++</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    ListNode *a = NULL;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    while(head)&#123;</span><br><span class="line">        ListNode *tmp = head-&gt;next;</span><br><span class="line">        head-&gt;next = a;</span><br><span class="line">        a=head;</span><br><span class="line">        head=tmp;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###</p><h4 id="问题-41"><a href="#问题-41" class="headerlink" title="问题"></a>问题</h4><h4 id="思路-38"><a href="#思路-38" class="headerlink" title="思路"></a>思路</h4><h4 id="C-43"><a href="#C-43" class="headerlink" title="C++"></a>C++</h4><h4 id="收获-24"><a href="#收获-24" class="headerlink" title="收获"></a>收获</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;461-Hamming-Distance&quot;&gt;&lt;a href=&quot;#461-Hamming-Distance&quot; class=&quot;headerlink&quot; title=&quot;461. Hamming Distance&quot;&gt;&lt;/a&gt;461. Hamming Distance&lt;/h3
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://github.com/zhujiaxiang/zhujiaxiang.github.io/2018/07/23/HTML%E5%AD%A6%E4%B9%A0/"/>
    <id>https://github.com/zhujiaxiang/zhujiaxiang.github.io/2018/07/23/HTML学习/</id>
    <published>2018-07-23T02:16:00.101Z</published>
    <updated>2018-08-30T08:20:49.052Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>超文本标记语言  (英语：Hypertext Markup Language，简称：HTML )  是一种用来结构化 Web 网页及其内容的标记语言。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;My cat is very grumpy&lt;/p&gt;</span><br></pre></td></tr></table></figure></p><p>这个元素的主要部分有：</p><p>开始标签（The opening tag）：这里包含了元素的名称（本例为 p），被开、闭尖括号所包围。这表示元素从此开始或者开始起作用——在本例中即段落由此开始。<br>闭合标签（The closing tag）：与开始标签相似，只是其在元素名之前包含了一个斜杠。这表示着元素的结尾——这表示元素在此结束——在本例中即段落在此结束。初学者常常会犯忘记包含闭合标签的错误，这可能会产生一些奇怪的结果。<br>内容（The content）：这是一个元素的内容，这个例子中就是所输入的文本本身。<br>元素（The element）：开标签、闭标签与内容相结合，便是一个完整的元素。<br>同时元素也可以有属性 如<figure class="highlight plain"><figcaption><span>class</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一个属性应该包含：  </span><br><span class="line">1.在属性与元素名称（或上一个属性，如果有超过一个属性的话）之间的空格符。  </span><br><span class="line">2.属性的名称，并接上一个等号。  </span><br><span class="line">3.由引号所包围的属性值。  </span><br><span class="line"></span><br><span class="line">有一些元素并不包含内容，它们被称为空元素。看看我们 HTML 代码中已经存在的 &lt;img&gt; 元素：</span><br></pre></td></tr></table></figure></p><p><img src="images/firefox-icon.png" alt="My test image"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">它包含了两个属性，但是这里并没有 &lt;/img&gt; 闭合标签，也没有内部内容。因为图像元素不需要包含内容来产生效果，它的作用是向其所在的位置嵌入一个图像。</span><br><span class="line"></span><br><span class="line">在HTML中，每个段落是通过&lt;p&gt; 元素标签进行定义的, 比如下面这样：</span><br></pre></td></tr></table></figure></p><p></p><p>I am a paragraph, oh yes I am.</p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每个标题（Heading）是通过“标题标签”进行定义的：</span><br></pre></td></tr></table></figure><p></p><p></p><h1>I am the title of the story.</h1><br><code>`</code><p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;超文本标记语言  (英语：Hypertext Markup Language，简称：HTML )  是一种用来结构化 Web 网页及其内容的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://github.com/zhujiaxiang/zhujiaxiang.github.io/2018/07/23/JS%E5%AD%A6%E4%B9%A0/"/>
    <id>https://github.com/zhujiaxiang/zhujiaxiang.github.io/2018/07/23/JS学习/</id>
    <published>2018-07-23T02:16:00.101Z</published>
    <updated>2018-09-11T10:17:36.103Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="JS学习"><a href="#JS学习" class="headerlink" title="JS学习"></a>JS学习</h2><h4 id="模板字符串-文档"><a href="#模板字符串-文档" class="headerlink" title="模板字符串 文档"></a>模板字符串 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/template_strings" target="_blank" rel="noopener">文档</a></h4><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>1.内含占位符，可以自由插入表达式，写法更优雅，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = 5;</span><br><span class="line">var b = 10;</span><br><span class="line">console.log(`Fifteen is $&#123;a + b&#125; and</span><br><span class="line">not $&#123;2 * a + b&#125;.`);</span><br><span class="line">// &quot;Fifteen is 15 and</span><br><span class="line">// not 20.&quot;</span><br></pre></td></tr></table></figure></p><p>2.可以直接获取多行字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(`string text line 1</span><br><span class="line">string text line 2`);</span><br><span class="line">// &quot;string text line 1</span><br><span class="line">// string text line 2&quot;</span><br></pre></td></tr></table></figure></p><p>3.支持嵌套模板  </p><p>4.带标签的模板字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var person = &apos;Mike&apos;;</span><br><span class="line">var age = 28;</span><br><span class="line">HTML</span><br><span class="line">function myTag(strings, personExp, ageExp) &#123;</span><br><span class="line"></span><br><span class="line">  var str0 = strings[0]; // &quot;that &quot;</span><br><span class="line">  var str1 = strings[1]; // &quot; is a &quot;</span><br><span class="line"></span><br><span class="line">  // There is technically a string after</span><br><span class="line">  // the final expression (in our example),</span><br><span class="line">  // but it is empty (&quot;&quot;), so disregard.</span><br><span class="line">  // var str2 = strings[2];</span><br><span class="line"></span><br><span class="line">  var ageStr;</span><br><span class="line">  if (ageExp &gt; 99)&#123;</span><br><span class="line">    ageStr = &apos;centenarian&apos;;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    ageStr = &apos;youngster&apos;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return str0 + personExp + str1 + ageStr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var output = myTag`that $&#123; person &#125; is a $&#123; age &#125;`;</span><br><span class="line"></span><br><span class="line">console.log(output);</span><br><span class="line">// that Mike is a youngster</span><br></pre></td></tr></table></figure></p><p>5.通过属性raw可以输出原始字符串，不用单独转义，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function tag(strings) &#123;</span><br><span class="line">  console.log(strings.raw[0]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tag`string text line 1 \n string text line 2`;</span><br><span class="line">// logs &quot;string text line 1 \n string text line 2&quot; ,</span><br><span class="line">// including the two characters &apos;\&apos; and &apos;n&apos;</span><br></pre></td></tr></table></figure></p><h4 id="js中增删改查元素"><a href="#js中增删改查元素" class="headerlink" title="js中增删改查元素"></a>js中增删改查元素</h4><h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><h5 id="createElement-appendChild"><a href="#createElement-appendChild" class="headerlink" title="createElement appendChild"></a>createElement appendChild</h5><p>var button = document.createElement(‘button’)<br>var form = document.querySelector(‘.login-form’)<br>form.appendChild(button)  </p><h5 id="为div-添加子元素-2最常用"><a href="#为div-添加子元素-2最常用" class="headerlink" title="为div 添加子元素 (2最常用)"></a>为div 添加子元素 (2最常用)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（1）div.innerHTML += &apos;&lt;h1&gt;xxx&lt;/h1&gt;&apos;       （2）div.insertAdjacentHTML(&apos;beforeend&apos;,&apos;&lt;h1&gt;xxx&lt;/h1&gt;&apos;)</span><br></pre></td></tr></table></figure><h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><p>var button = document.querySelector(‘button’)<br>form.removeChild(button)<br>或<br>button.remove()  </p><h4 id="改"><a href="#改" class="headerlink" title="改"></a>改</h4><p>var button = document.querySelector(‘button’)<br>buntton.innerHTML = ‘注册用户’  </p><h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><h5 id="属于-W3C-中的-Selectors-API-规范"><a href="#属于-W3C-中的-Selectors-API-规范" class="headerlink" title="属于 W3C 中的 Selectors API 规范"></a>属于 W3C 中的 Selectors API 规范</h5><p>元素选择器<br>var body = document.querySelector(‘body’)<br>class选择器<br>var form = document.querySelector(‘.login-form’)<br>id选择器<br>var loginButton = document.querySelector(‘#id-button-login’)<br>这三种获取的是静态集合（选择出后便与文档的变化无关）且性能较差</p><h5 id="属于-W3C-的-DOM-规范"><a href="#属于-W3C-的-DOM-规范" class="headerlink" title="属于 W3C 的 DOM 规范"></a>属于 W3C 的 DOM 规范</h5><p>document.getElementById(‘idName’);<br>返回一个与之对应id属性的节点对象</p><p>document.getElementsByTagName(tagName);<br>返回一个对象数组（准确的说是HTMLCollection集合）,返回元素的顺序是它们在文档中的顺序,传递给 getElementsByTagName() 方法的字符串可以不区分大小写,</p><p>document.getElementsByClassName(‘className’);<br>返回文档中所有指定类名的元素集合</p><h4 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h4><h5 id="写法："><a href="#写法：" class="headerlink" title="写法："></a>写法：</h5><p>（1）内联写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 style=&quot;background:red;&quot;&gt;sth&lt;/h1&gt;  </span><br><span class="line">```  </span><br><span class="line">缺点：维护不方便，相同样式发生修改要修改多处   </span><br><span class="line"></span><br><span class="line">（2）head标签内的style标签写法：</span><br></pre></td></tr></table></figure></p><p><style><br>    h1{<br>        background:red;<br>    }<br></style><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">缺点：html文件会相当臃肿   </span><br><span class="line">（3）link标签外联写法：</span><br><span class="line">新建一个xxx.css文件，并加上&lt;link rel=&quot;stylesheet&quot; href=&quot;xxx.css&quot;&gt;</span><br><span class="line">并在css文件中编写样式</span><br><span class="line"></span><br><span class="line">有不同的写法便有不同的优先级，样式优先级如下（从高到低，低的会被高的覆盖）：  </span><br><span class="line">1.！important</span><br></pre></td></tr></table></figure></p><p>h1{<br>    background:orange !important;<br>}<br><code>`</code><br>2.内联样式<br>3.link，style样式（同级样式，后面会覆盖前面的）</p><p>同样，我们可以通过选择器对样式进行修改，选择器同样有优先级，优先级如下：<br>（1）id选择器<br>（2）class选择器<br>（3）元素选择器</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;JS学习&quot;&gt;&lt;a href=&quot;#JS学习&quot; class=&quot;headerlink&quot; title=&quot;JS学习&quot;&gt;&lt;/a&gt;JS学习&lt;/h2&gt;&lt;h4 id=&quot;模板字符串-文档&quot;&gt;&lt;a href=&quot;#模板字符串-文档&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>React Native</title>
    <link href="https://github.com/zhujiaxiang/zhujiaxiang.github.io/2018/07/23/React%20Native/"/>
    <id>https://github.com/zhujiaxiang/zhujiaxiang.github.io/2018/07/23/React Native/</id>
    <published>2018-07-23T02:16:00.101Z</published>
    <updated>2018-08-28T09:23:45.886Z</updated>
    
    <content type="html"><![CDATA[<h4 id="RN解决的问题"><a href="#RN解决的问题" class="headerlink" title="RN解决的问题"></a>RN解决的问题</h4><p>设计理念：使用React Native开发，既拥有Native的良好人机交互体验，又保留了React框架的开发效率（TODO:开发效率莫非很高？）。其提供的解决方案可以称为“一次学习，随处编写（Learn once,write anywhere）”</p><h4 id="重要特性与强项"><a href="#重要特性与强项" class="headerlink" title="重要特性与强项"></a>重要特性与强项</h4><p>1.一次学习，随处编写（开发思路相同，不同平台上的代码根据平台会有微小的区别，）<br>2.混合开发  </p><ul><li>UI与业务逻辑由React Native开发，与手机平台紧密关联的处理由原生执行  </li><li>可将UI控件包装为RN自定义组件  </li><li>RN界面与原生界面能自由切换</li></ul><p>3.独特的UI实现框架，使用React开发，开发者只需关心数据，当数据改变时，只需通知React数据变了，由React来实现UI界面的改变（状态机变量与属性）<br>4.组件化开发<br>5.跨平台移植代码迅速（需要适配部分的代码只有总代码的5%甚至更低）<br>6.通过灵活的布局方式，适配不同屏幕大小的手机<br>7.高效的开发调试（做出改动不用重编译，可以立刻看到效果）<br>8.hotfix方便<br>9.包体积有效降低<br>10.开发语言简单（ES6,JSX），接近自然语言（和OC命名风格差不多）<br>11.积木式UI  </p><h4 id="代价"><a href="#代价" class="headerlink" title="代价"></a>代价</h4><p>1.内存消耗大<br>2.在最优条件下运行速度比原生代码慢，菜鸡来开发，RN甚至有优势  </p><h4 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h4><p>1.版本号的知识，递增规则如下以0.41为例（主版本号.次版本号）  </p><ul><li>xcode安装  </li><li>brew install node  </li><li>brew install watchman  </li><li>npm install -g<br>2.IDEA选择：atom+nuclide/vscode<br>3.TODO:React Dev Tools安装（已完成）</li></ul><h4 id="状态机思维与状态机变量"><a href="#状态机思维与状态机变量" class="headerlink" title="状态机思维与状态机变量"></a>状态机思维与状态机变量</h4><p>1.react-native init LearnRN 初始化项目<br>2.模拟重启，在项目根目录输入命令react-native start<br>3.RN生命周期函数中使用console.log打印日志非常容易引发问题（红屏）<br>4.cmd+d唤出development，点击remote JS Debugging按钮，在启动的chrome界面按下cmd+opt+j即可调出调试界面（前提是chrome安装了React Dev Tools插件）<br>5.JSX注释不能用//进行代码注释，需要以{/<em>开头，以</em>/}结束，并且中间注释的文字可以跨行。<br>6.状态机变量为不可变常量，不要出现“this. </p><p>state,某状态机变量名 = 某值”，当开发者需要改变状态机变量时，应使用this.setState函数。<br>7.尽量减少有状态的RN组件的数目，可以让状态机变量放在合理的地方，减少代码冗余，使程序框架清晰<br>8.好的RN设计思路：创建多个负责渲染数据的无状态组件，将其封装在有状态的RN组件中，并把这个有状态的RN组件的状态机变量值通过props传给无状态RN组件，使无状态RN组件成为有状态RN组件的子组件  </p><h4 id="组件回调函数的绑定"><a href="#组件回调函数的绑定" class="headerlink" title="组件回调函数的绑定"></a>组件回调函数的绑定</h4><p>1.使用箭头函数指向回调，如：<br>onChangeText = {(newText) =&gt; this.updateNum(newText)};<br>2.回调函数使用箭头函数定义，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">updateNum = （newText）=&gt; &#123;  </span><br><span class="line">this.setState((state)=&gt;&#123;</span><br><span class="line">return&#123; inputedNum:newText,</span><br><span class="line">&#125;;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.先在构造函数中绑定updatePW函数：<br>this.updatePW=this.updatePW.bind(this)<br>随后在render中直接使用onChangeText={this.updatePW}</p><h4 id="组件平台自适配"><a href="#组件平台自适配" class="headerlink" title="组件平台自适配"></a>组件平台自适配</h4><p>1.将文件名改为XXX.ios.js<br>2.使用RN提供的Platform API判断，如下：<br>if(Platform.OS == “android”)</p><h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><p>1.修改代码要保存后cmd+R刷新显示<br>2.在text中引用变量使用{变量}而不是(变量)<br>3.代码补全需要先引库<br>4.书中第三章使用的导航组件为Navigator，在demo中使用发现没有对应的sceneConfigs等属性，咨询了一下RN的同学发现两年前就已经弃用了这个组件，现在重点看的学习资料转向<a href="https://reactnative.cn/docs/getting-started/" target="_blank" rel="noopener">https://reactnative.cn/docs/getting-started/</a> 官网的教程了，以书为辅<br>5.今日RN开发踩到一个坑，根据官方文档的指引，添加导航库<br><code>yarn add react-navigation</code><br>后，运行代码报错<code>Module `react-navigation` does not exist in the Haste module map</code> 解决方法，关闭RN项目自启的命令行，切断桥接，重新运行项目</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;RN解决的问题&quot;&gt;&lt;a href=&quot;#RN解决的问题&quot; class=&quot;headerlink&quot; title=&quot;RN解决的问题&quot;&gt;&lt;/a&gt;RN解决的问题&lt;/h4&gt;&lt;p&gt;设计理念：使用React Native开发，既拥有Native的良好人机交互体验，又保留了React
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>机器学习常见名词解释</title>
    <link href="https://github.com/zhujiaxiang/zhujiaxiang.github.io/2018/06/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>https://github.com/zhujiaxiang/zhujiaxiang.github.io/2018/06/25/机器学习/</id>
    <published>2018-06-25T10:26:43.070Z</published>
    <updated>2018-07-23T09:22:48.718Z</updated>
    
    <content type="html"><![CDATA[<p>学习算法：在计算机上从数据中产生模型的算法<br>示例（样本）：数据集中每条关于一个事件或对象的记录<br>属性，特征：反映事件或对象在某方面的表现或性质的事项<br>属性值：属性上的取值<br>属性空间，样本空间，输入空间：属性张成的空间<br>特征向量：由于空间中的每个点对应一个坐标向量，因此我们把一个示例也称为特征向量<br>维数：一个示例Xi由N个属性来描述，我们便称样本有N维<br>学习，训练：从数据中学得模型的过程，这个过程通过执行某个学习算法来完成<br>训练数据：训练过程中使用的数据<br>训练样本：训练数据中的每一个示例（样本）<br>训练集：训练样本组成的集合<br>假设：学得模型对应了关于数据的某种潜在的规律<br>真相，真实：潜在规律的自身<br>学习器：模型的别称<br>预测：帮助判断某个假设（判断没剖开的是不是好瓜）<br>标记：示例结果的信息（好瓜，坏瓜）<br>样例：拥有了标记信息的示例<br>标记空间，输出空间：所有标记的集合<br>分类：预测的是离散值，例如“好瓜”，“坏瓜”<br>回归：预测的是连续值，例如西瓜成熟度0.95，0.98<br>正类，反类：只涉及两个类别的“二分类”任务<br>多分类：涉及多个类别时<br>测试：学得模型后，使用其进行预测的过程<br>测试样本：被预测的样本<br>聚类：将训练集中的训练样本瓜分成若干组<br>簇：每组称为一个簇，这些自动形成的簇可能对应一些潜在的概念<br>监督学习：训练数据有标记信息，代表为分类和回归<br>非监督学习：训练数据无标记信息，代表为聚类<br>泛化：学得模型适用于新样本的能力<br>独立同分布：获得的每个样本都是独立的从一个分布上采样获得的<br>归纳：从特殊到一般的泛化过程<br>演绎：从一般到特殊的特化过程<br>归纳学习：从样例中学习，归纳的过程，广义上的归纳学习大体相当于从样例中学习。狭义的归纳学习则要求从训练数据中学得概念，所以又称概念学习或概念形成。<br>假设空间：所有假设组成的空间<br>版本空间：与训练集一致（即对所有训练样本能够进行正确判断）的“假设集合”<br>归纳偏好：机器学习算法在学习过程中对某种类型假设的偏好，称为归纳偏好。例如模型更偏好根蒂来判断好瓜坏瓜。<br>奥卡姆剃刀：是一种常用的，自然科学研究中最基本的原则，即“若有多个假设与观察一致，则选最简单的那个”<br>没有免费的午餐定理NFL：无论算法多机智，期望性能相同<br>数据挖掘：从海量数据中发掘知识，对数据的管理和分析。<br>深度学习：狭义说是“很多层”的神经网络，缺乏严格的理论基础，设计的模型复杂度非常高，需要下功夫调参。<br>错误率与精度:分类错误的样本占样本总数的比例称为错误率，如果在m个样本中有a个样本分类错误，则错误率E=a/m；相应的1-a/m称为精度<br>过拟合：将训练样本自身的一些特点当做了所有潜在样本都会有的一般性质，这样就会导致泛化性能下降，称为过拟合。<br>欠拟合：与过拟合相对，对训练样本的一般性质尚未学好<br>评估方法-留出法：将训练集D划分为两个互斥的集合，其中一个集合作为训练集S。另一个作为测试集T，在S上训练处模型后，用T来评估其测试误差，作为对泛化误差的估计。不同的划分会导致不同的训练/测试集，所以单次使用留出法得到的估计结果往往不够稳定可靠，在使用留出法时，一般要采用若干次随即划分，重复进行实验评估后取平均值作为留出法的评估结果。<br>分层采样：保留类别比例的采样方式<br>交叉验证法（k折交叉验证）：先将数据集D划分为k个大小相似的互斥子集，每个子集都尽可能保持数据分布的一致性，即通过分层采样得到。每次用k-1个子集的并集作为训练集，余下的那个子集作为测试集，这样就可获得k组训练/测试集，从而可进行k次训练和测试，最终返回的事k个测试结果的均值。<br>自助法：我们希望评估的是D训练出的模型。但在留出法和交叉验证发中，由于保留了一部分样本用于测试，因此实际评估的模型所使用的训练集比D小，这必然会引入一些因训练样本规模不同二导致的估计偏差。对于给定包含m个样本的数据集D，我们对它采样产生数据集D‘：每次随即从D中挑选一个样本，将其拷贝放入D’，然后再将该样本放回初始数据集D中，使得该样本在下次采样时仍有可能被采到；这个过程重复执行m次后，我们就得到了包含m个样本的数据集D’，这就是自助采样的结果。显然。一部分样本会多次出现，另一部分不出现，样本在m次采样中始终不被采到的概率是（1-1/m）的m次方，取极限约等于0.368.于是我们将D’作为训练集，D/D’作为测试集，这样实际评估的模型与期望评估的模型都是用m个样本，而仍有数据总量三分之一的未在训练集中出现的样本用于测试，这样的测试结果也称作包外估计。自助法在数据集较小，难以划分训练/测试集时很有用。然而。自助法产生的数据改变了分布，引入了估计偏差，因此在初始数据量足够时，留出法和交叉验证法更常用。<br>错误率与精度：错误率是分类错误的样本数占样本总数的比例，精度=1-错误率<br>查准率与查全率：对于二分类问题，可将样例根据真实类别与学习期预测类别的组合划分为真正例（true positive），假正例（false positive），真反例（true negative），假反例（false negative）四种情形  </p><table><thead><tr><th>真实情况</th><th>正例</th><th>反例</th></tr></thead><tbody><tr><td>正例</td><td>TP(真正例)</td><td>FN(假反例)</td></tr><tr><td>反例</td><td>FP(假正例)</td><td>TN（真反例）</td></tr></tbody></table><p>查准率： P=TP/TP+FP<br>查全率： R=TP/TP+FN</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习算法：在计算机上从数据中产生模型的算法&lt;br&gt;示例（样本）：数据集中每条关于一个事件或对象的记录&lt;br&gt;属性，特征：反映事件或对象在某方面的表现或性质的事项&lt;br&gt;属性值：属性上的取值&lt;br&gt;属性空间，样本空间，输入空间：属性张成的空间&lt;br&gt;特征向量：由于空间中的每个
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>机器学习及深度学习</title>
    <link href="https://github.com/zhujiaxiang/zhujiaxiang.github.io/2018/06/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    <id>https://github.com/zhujiaxiang/zhujiaxiang.github.io/2018/06/25/深度学习/</id>
    <published>2018-06-25T10:26:43.070Z</published>
    <updated>2018-09-17T07:11:25.983Z</updated>
    
    <content type="html"><![CDATA[<p>一，机器学习：<br>1.模式识别<br>2.数据挖掘<br>3.统计学习<br>4.计算机视觉<br>5.语音识别<br>6.自然语言处理  </p><p>二，学习思路  </p><ol><li>人类学习的思路：通过观察总结经验获取技能  </li><li>机器学习的思路：通过数据积累（计算）经验获取技能<br>有监督学习：<br>给定输入，预测输出<br>分类，回归<br>半监督学习：<br>使用部分有监督数据+无监督数据<br>无监督学习：<br>挖掘输入数据好的特征表示<br>聚类，降维<br>增强学习：<br>在环境给予的奖励或惩罚的刺激下，逐步做出最大利益的习惯性行为</li></ol><p>三，Deep Learning = Learning Representations/Features<br>1.传统模式识别：固定特征提取器或者手工制造<br>2.端对端学习 特征学习，深度学习，Trainable Feature Extractor，Trainable Classifier<br>3.如果存在多个非线性特征变换，那么它就是深度的<br><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fv95j96w19j31kw0sv1ky.jpg" alt="avatar"><br>四，发展历程ILSVRC<br><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fv95loboe9j31kw0qm13d.jpg" alt="avatar"><br>重点GoogleNet：宽度，Inception Module<br>MSRA<br><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fv95nm2dmhj31kw0wn7ql.jpg" alt="avatar"><br>五，激活函数<br>激活函数（Activation functions）对于人工神经网络模型去学习、理解非常复杂和非线性的函数来说具有十分重要的作用。它们将非线性特性引入到我们的网络中。在神经元中，输入的 inputs 通过加权，求和后，还被作用了一个函数，这个函数就是激活函数。引入激活函数是为了增加神经网络模型的非线性。没有激活函数的每层都相当于矩阵相乘。就算你叠加了若干层之后，无非还是个矩阵相乘罢了。<br><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fvcbq4hsz2j31kw0qnwux.jpg" alt="avatar"><br>六，常用的激活函数<br><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fvcbqz137lj31kw0v47li.jpg" alt="avatar"><br>七，全连接网络<br><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fvcbroe6e7j31kw0vxnif.jpg" alt="avatar"><br>八，卷积神经网络<br><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fvcedgdjwjj31kw0s3apc.jpg" alt="avatar"><br>九，图像卷积<br><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fvciu50eeij31kw0uk7mu.jpg" alt="avatar"></p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fvcj1ynxvnj31kw0vr7wh.jpg" alt="avatar"><br>十，不同的图像卷积示例<br><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fvcj8viyelj31kw0pbkjl.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fvcj94uourj31kw0szx6q.jpg" alt=""><br><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fvcj9iaj7tj31kw0udkjm.jpg" alt=""><br><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fvcjas7kmjj31kw0ut4qq.jpg" alt=""><br>十一，MaxPooling<br><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fvcjedrpf5j31kw0q5q7q.jpg" alt=""><br>十二，全连接层<br><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fvcjjwtgvej31kw0u27w5.jpg" alt=""><br>十三，卷积神经网络<br><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fvcjjbrl0mj31kw0lqn4d.jpg" alt=""><br>十四，几种重要的CNN结构<br><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fvcjpj2orwj31kw0q64l6.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fvcjpu3xsvj31kw0shngy.jpg" alt=""><br><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fvcjq6szz1j31kw0tok8d.jpg" alt=""><br>十五，网络结构配置文件<br><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fvcjs4wkgij31kw0rvqv5.jpg" alt=""><br>十六，深度学习应用领域<br><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fvcjsxhjecj31kw0t14qq.jpg" alt=""><br>十七，图像分析<br><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fvcjtvku43j31kw0w4npd.jpg" alt=""><br>十八，图像检测<br><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fvcjutnw74j31kw0txb2a.jpg" alt=""><br>十九，图像识别<br><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fvcjvpfvrxj31kw0pub29.jpg" alt=""><br>二十，语义分割<br><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fvcjx6xmv0j31kw0sce81.jpg" alt=""><br>二十一，图像语义检测<br><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fvcjxvx50kj31kw0sau0x.jpg" alt=""><br>二十二，姿态估计<br><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fvcjyk9n3mj31kw0rk1ky.jpg" alt=""><br>二十三，服饰关键点预测与属性识别<br><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fvcjyziaxkj31kw0su7wi.jpg" alt=""><br><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fvcjz8xduuj31kw0qgqhf.jpg" alt=""><br>二十四，模特换装<br><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fvcjzpda1jj31kw0qyx6p.jpg" alt=""><br>二十五，人脸识别<br><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fvcjzxyqxgj31kw0mrh2y.jpg" alt=""><br>二十六，图像超分辨率<br><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fvck0lk34hj31kw0qv1ky.jpg" alt=""><br>二十七，高清图像生成<br><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fvck1g5l93j31kw0oqx6p.jpg" alt=""><br><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fvck1nfr0kj31kw0qnnpd.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一，机器学习：&lt;br&gt;1.模式识别&lt;br&gt;2.数据挖掘&lt;br&gt;3.统计学习&lt;br&gt;4.计算机视觉&lt;br&gt;5.语音识别&lt;br&gt;6.自然语言处理  &lt;/p&gt;
&lt;p&gt;二，学习思路  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;人类学习的思路：通过观察总结经验获取技能  &lt;/li&gt;
&lt;li&gt;机器学
      
    
    </summary>
    
    
  </entry>
  
</feed>
